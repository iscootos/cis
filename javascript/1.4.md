#面向对象与原型
创建一个对象，然后给这个对象自定义属性和方法
```js
var foo = new Object();  //创建对象
foo.name = 'allen.w';  //添加属性
foo.age = 27;
foo.run = function() {  //添加方法
	return this.name + this.age + '运行中...';
};

alert(foo.run());
```
####工厂模式
为了解决多个类型对象声明的问题，我们可以使用一个叫做工厂模式的方法
```js
function createObject(name, age) {
	var obj = new Object();
	obj.name = name;
	obj.age = age;
	obj.run = function() {
		return this.name + this.age + '运行中...';
	};

	return obj;
}

var foo = createObject('allen.w', 27);
var bar = createObject('iro',28);
alert(foo.run());
alert(bar.run());
```
####构造函数
构造函数(构造方法)可用来创建特定的对象
```js
function obj(name, age) {
	this.name = name;
	this.age = age;
	this.run = function() {
		return this.name + this.age + '运行中...';
	};
}

var foo = new obj('allen.w', 27);
var bar = new obj('iro', 28);
alert(foo.run());
alert(bar.run());
```
从上面我们得出，以下3点
1.构造函数没有`new Object()`，但后台会自动`var obj = new Object()`
2.this就是obj
3.构造函数不需要返回对象引用，它是后台自动返回的       

构造函数名第一个字母，最好使用大写，以区别普通函数和构造函数       
通过构造函数创建对象，必须使用new运算符        
```js
alert(foo instanceof Object);  //true
alert(foo instanceof obj);  //true
```
函数的引用地址
```js
function Box() {
	this.run = run;
}

function run() {
	return 123;
}

var foo = new Box();
var bar = new Box();
alert(foo.run == bar.run);   //true
```
如上，函数不加`()`就是指向函数的地址，上面就是判断的地址，所以是true
####name变量
```js
alert(name);
alert(this.name);
alert(window.name);
```
执行以上语句，我们会发现，会输出空，所以我们尽量不要使用name作为变量名
####原型
每个函数都有一个prototype(原型)属性，这个属性是一个对象，它的用途是包含可以由特定类型的所有实例共享的属性和方法           
也就是说，给构造函数创建的原型属性或原型方法，通过这个构造函数创建的对象都可以使用这些属性和方法            
那么我们理解为，构造函数，创建了一个类，原型，就是给这个类，创建属性和方法            
```js
function User() {};

User.prototype.name = 'allen.w';
User.prototype.age = 27;
User.prototype.run = function() {
	return this.name + this.age + '运行中...';
};

var foo = new User();
document.write(foo.run());
```
原型对象方法`isPrototypeOf()`，判断一个实例化的对象，是否指向原型对象
```js
function User() {};

var foo = new User();
document.write(User.prototype.isPrototypeOf(foo));  //true
```
那么说明，所以的实例化构造函数，都有原型对象         
```js
function User() {
	this.user = 'Jack';  //实例属性
}

User.prototype.user = 'Lee';  //原型属性

var foo = new User();
alert(foo.user);  //'Jack' 使用的实例属性
foo.user = 'Geek';   //实例属性，没有重写原型
alert(foo.user);  //'Geek'
```
如上，构造函数内部的是实例属性和实例方法，原型对象里面的是原型对象和原型方法           
程序先在实例里面找属性和方法，没有的话，再到原型里面找，而且原型里面的属性和方法，是所有实例化对象共享的，修改一个，就等于所有的都修改了
```js
function User() {}

User.prototype.user = 'Lee';

var foo = new User();
var bar = new User();
alert(foo.user);  //'Lee'
alert(bar.user);  //'Lee'
User.prototype.user = 'Jack';
alert(foo.user);  //'Jack'
alert(bar.user);  //'Jack'
```
那么我们怎么访问实例属性和原型属性呢，如下，删除实例属性，就可以看到原型属性了
```js
function User() {}

User.prototype.user = 'Lee';

var foo = new User();
foo.user = 'Jack';  //实例属性，没有重写原型
alert(foo.user);  //'Jack'
delete foo.user;  //输出实例属性
alert(foo.user);  //'Lee' 输出原型属性
```
如何判断属性在实例还是原型里面呢，可以使用`hasOwnProperty()`函数，实例中有返回true,否则返回false
```js
function User() {
	this.user = 'Lee';
}

User.prototype.user = 'Jack';
var foo = new User();
alert(foo.hasOwnProperty('user'));  //true
```
`in`操作符，能够判断属性无论是在实例中，还是原型中，都返回true,否则false          
那么晚我们就可以，通过`in`操作符和`hasOwnProperty()`函数判断属性是否在原型中
```js
function User() {}

User.prototype.user = 'Jack';
var foo = new User();
alert('user' in foo);  //true
```
```js
function User() {}

User.prototype.user = 'Jack';
var foo = new User();

function isProperty(obj, property) {
	return (!obj.hasOwnProperty(property) && property in obj)
}

alert(isProperty(foo, 'user'));  //true
```
####使用原型封装构造函数
```js
function User() {}
User.prototype.user = 'Jack';
var foo = new User();
alert(foo.prototype);  //undefined，访问不了
alert(foo.__proto__);  //原型对象的指针地址
alert(User.prototype);  //但可以通过构造函数访问
```
这里`__proto__`指向的就是原型的地址，而原型的`constructor`属性指向构造函数
```js
function User() {}
User.prototype.user = 'Jack';
var foo = new User();
alert(foo.constructor == User);  //true
```
这里，我们发现，下面的原型`User.prototype = {}`，其实创建了一个新的对象，所以它的`constructor`属性，指向的就是这个对象的地址，而不是构造函数的地址，那么就会出现一些问题
```js
function User() {}

User.prototype = {
	name : 'Jack',
	age : 27,
	run : function() {
		return this.name + this.age + '运行中...';
	}
};

var foo = new User();

alert(foo.constructor == User);  //false
alert(foo.constructor == Object);  //true
```
那么，我们强制把`User.prototype = {}`对象的`constructor`属性，指向构造函数
```js
function User() {}

User.prototype = {
	constructor : User,
	name : 'Jack',
	age : 27,
	run : function() {
		return this.name + this.age + '运行中...';
	}
};

var foo = new User();

alert(foo.constructor == User);  //true
```


