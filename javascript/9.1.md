#JS
####NamespacesPrototype()函数
NamespacesPrototype()构造函数，有两个方法create()和register()方法                   

create()方法有两个参数         
第一个参数是一个字符串，用于表示要创建的对象的字面量形式的字符串，用点好分开，如`x.net`，就表示将要创建两个对象`window.x = {}, window.x.net = {}`，如果字符串更长，依次类推            
第二个参数是一个构造函数，用于第一个参数的最后一个对象的值, 例如第一个参数是`x.net`回调函数是f,那么结果就是`window.x.net = new f()`,也就是说，当赋值的时候，这个回调函数就执行了             

register()方法更create()方法，用法是一样的，唯一的不同就是，`window.x.net = new f`，也就是赋值的是函数，而不是函数执行之后的结果          

下面我们讲讲这个函数是如何实现的，首先，我们把一个对象的字符串字面量`x.net`通过参数传递进去，然后通过split()方法使用`.`点号分隔为数组            
然后我们使用shift()方法取出数组的第一个值，并把这个值作为对象的名称创建一个对象`window.x = {}`,递归创建，直到取出的是最后一个值了，那么`window.x = fucntion(){}`那么 创建的就是一个方法了               
同时在创建对象的时候，给每一个对象都创建了两个属性_path和_parent属性，_path是当前对象字面量字符串，_parent是父对象字面量字符串          
最后我们创建了一个变量，并初始化了这个构造函数           
```js
function NamespacesPrototype() {
	function b(c, d, e) {
		c[d] = e;
		e._path = c._path ? (c._path + "." + d) : d;
		e._parent = c
	}
	function a(d, f, c) {
		var e = f.shift();
		if (0 == f.length) {
			b(d, e, c())
		} else {
			if (!d[e]) {
				b(d, e, {})
			}
			a(d[e], f, c)
		}
	}
	this.create = function(d, c) {
		a(window, d.split("."),
		function() {
			return new c()
		})
	};
	this.register = function(d, c) {
		a(window, d.split("."),
		function() {
			return c
		})
	}
}
var Namespaces;
if (!Namespaces) {
	Namespaces = new NamespacesPrototype()
};
```
示例
```js
Namespaces.create('x.net', function(){
	alert('x.net');
});
Namespaces.register('x.log', function(x){
	alert(x);
});
x.log('x.log');
```
####JSLoader()
下面我们通过Namespaces.create方法，创建了一系列对象`com.netease.mail.common.JSLoader`，它的值是一个构造函数，有两个方法mark和include方法                  

include方法有三个参数k,p,o          
第一个参数，是一个数组，里面存储的是URL地址，如`['demo.php','tmp.php']`               
第二个参数，是一个回调函数           
第三个参数，            

这里我们重要讲解下这个构造函数          
首先创建了三个对象f,b,e             
include方法         
先创建了一个局部对象j,`var j = {flag:0, srcs:{}, callback:p}` ,而callback属性的值就是第二个参数p了，也就是回调函数             
再创建了一个局部变量m,检查参数p是否为function,真true,假false                
那么它的作用就是现在先判断一个f对象中的URL地址的值是否为3，如果不是那么把b对象中URL地址的赋值为对象j，并设置j对象的flag标志为0,j对象下srcs对象下的URL属性值1           
在f对象中的URL不等于3的条件下，判断f对象中是否有该URL地址的属性，如果没有，那么声明并初始化为1 ,然后判断该属性值是否为1,肯定是1，因为我们刚刚设置了，如果不是函数终止，如果是，把该值设置为2,然后使用这个URL使用，执行ajax get请求，如果成功返回结果，作为js代码，动态添加到head,把该URL地址的属性修改为3   ，然后去b对象中检查flag的值，如果为0，那么修改为1,然后检查falg是否不为0,如果是，那么执行callback回调函数，最后把这个修改过的j放入一个空对象，再保存到b对象URL地址下的属性值,最后判断m是否为true,如果是那么执行p()函数          

通过以上复杂的讲解，最后我们得出,该构造函数内部的对象f存储的是ajax get请求URL地址的状态标志，1为请求前，2为准备中，3为完成后          
内部对象b存储的是一个数组，数组中是对象j,如果flag标志不为真，那么flag设置为1,在判断f对象的状态标志是否为3，如果不是，那么修改flag为0,最后判断flag的值，决定是否执行回调函数，最后把修改后的j对象保存在数组中，在赋值给b对象          
简而言之，就是f对象是get请求的状态值，属性名称就是GET请求的URL地址，值为状态             
b对象的属性名称，也是GET请求的URL地址，值是一个数组，数组里面有一个对象，对象里面保存了j对象          

那么使用方法就是，第一个参数为URL地址的数组，第二个是回调函数，但只要第一个URL地址获取成功后，才会执行一次回调函数          
```js
Namespaces.create("com.netease.mail.common.JSLoader",
function() {
	var f = {};
	var b = {};
	var e = {};
	var h = this;
	function a(n) {
		var o = b[n];
		if (o) {
			var m = [];
			for (var k = 0; k < o.length; k++) {
				var j = o[k];
				if (!j.flag) {
					j.flag = 1;
					for (var l in j.srcs) {
						if (3 != f[l]) {
							j.flag = 0;
							m.push(j);
							break
						}
					}
					if (j.flag) {
						j.callback()
					}
				}
			}
			b[n] = m
		}
	}
	function c(k) {
		var j = document.getElementsByTagName("HEAD").item(0);
		var i = document.createElement("script");
		i.language = "javascript";
		i.type = "text/javascript";
		i.text = k;
		j.appendChild(i)
	}
	function g(i) {
		if (1 != f[i]) {
			return
		}
		f[i] = 2;
		$.ajax({
			url: i,
			type: "GET",
			dataType: "text",
			success: function(k, j, l) {
				c(k);
				f[i] = 3;
				a(i)
			}
		})
	}
	function d(j, i) {
		if (!b[j]) {
			b[j] = []
		}
		var k = b[j];
		k.push(i)
	}
	this.mark = function(j) {
		for (var k = 0; k < j.length; k++) {
			var l = j[k];
			f[l] = 3
		}
	};
	this.include = function(k, p, o) {
		if (o) {
			if (e[o]) {
				return
			}
			e[o] = 1
		}
		var j = {
			flag: 0,
			srcs: {},
			callback: p
		};
		var m = typeof p == "function";
		for (var l = 0; l < k.length; l++) {
			var n = k[l];
			if (3 != f[n]) {
				if (m) {
					m = false;
					j.srcs[n] = 1;
					d(n, j)
				}
				if (!f[n]) {
					f[n] = 1;
					g(n)
				}
			}
		}
		if (m) {
			p()
		}
	}
});
```
