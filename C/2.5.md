#select
该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。         
也就是说，我们调用select告知内核对哪些描述符(读、写或异常条件)感兴趣以及等待多长时间。我们感兴趣的描述符不局限于套接字，任何描述符都可以使用select来测试。           
```c
#include <sys/select.h>
#include <sys/time.h>

int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);
```
返回值，若有就绪描述符则为其数目，若超时则为0，若出错则为-1              

我们从该函数的最后一个参数timeout开始介绍，它告知内核等待所指定描述符中的任何一个就绪可花多长时间，其timeval结构用于指定这段时间的秒数和微秒数。           
```c
struct timeval {
	long tv_sec;
	long tv_usec;
};
```
这个参数有以下三种可能              
1.永远等待下去，仅在有一个描述符准备好I/O时才返回。为此，我们把该参数设置为空指针。          
2.等待一段固定时间，在有一个描述符准备好I/O时返回，但是不超过由该参数所指向的timeval结构中指定的秒数和微秒数。         
3.根本不等待，检查描述符后立即返回，这称为轮询(polling)。为此，该参数必须指向一个timeval结构，而且其中的定时器值(由该结构指定的秒数和微秒数)必须为0。          

前两种情形的等待通常会被进程在等待期间捕获的信号中断，并从信号处理函数返回。
```text
    源自Berkeley的内核绝不自动重启被中断的select(TCPv2第527页)，然而SVR4可以
自动重启被中断的select，条件是在安装信号处理函数时指定了SA_RESTART标志。这意味
着从可移植性考虑，如果我们在捕获信号，那么必须做好select返回EINTER错误的准备。
```
尽管timeval结构允许我们指定了一个微妙级的分辨率，然而内核支持的真实分辨率往往粗糙得多。举例来说，许多Unix内核把超时值向上舍入成10ms的倍数。另外还涉及调度延迟，也就是说定时器时间到后，内核还需花一点时间调度相应进程运行。
```text
    如果timeval参数所指向的timeval结构中的tv_sec成员值超过1亿秒，那么有些系统的
select函数将以EINVAL错误失败返回，当然这是一个非常大的超时值（超过3年），不大可
能有用，不过就此指出，timeval结构能够表达select不支持的值。
```
timeout参数的const限定词表示它在函数返回时不会被select修改。举例来说，如果我们指定一个10s的超时值，不过在定时器到时之前select就返回了(结果可能是有一个或多个描述符就绪，也可能是得到EINTER错误)，那么timeout参数所指向的timeval结构不会被更新成该函数返回时剩余的秒数。如果我们需要知道这个值，那么必须在调用select之前取得系统时间，它返回后再取得系统时间，两者相减就是该值(任何健壮的程序都得考虑到系统时间可能在这段时间内偶尔会被管理员或ntpd之类守护进程调整)。              
```text
有些Linux版本会修改这个timeval结构，因此从移植性考虑，我们应该假设该timeval结构在select返回时未被定义，因而每次调用select之前都得对它进行初始化。POSIX规定对该结构使用const限定词。             
```
中间的三个参数readset、writeset和exceptset指定我们要让内核测试读、写和异常条件的描述符。目前支持的异常条件只有两个              
1.某个套接字的带外数据的到达             
2.某个已置为分组模式的伪终端存在可从其主端读取的控制状态信息                

如何给这3个参数中的每一个参数指定一个或多个描述符值是一个设计上的问题。select使用描述符集，通常是一个整数数值，其中每个整数中的每一位对应一个描述符。举例来说，假设使用32位整数，那么该数组的第一个元素对应于描述符0~31，第二个元素对应于描述符32~63，依次类推。所有这些实现细节都与应用程序无关，它们隐藏在名为fd_set的数据类型和以下四个宏中
```c
void FD_ZERO(fd_set *fdset);
void FD_SET(int fd, fd_set *fdset);
void FD_CLR(int fd, fd_set *fdset);
void FD_ISSET(int fd, fd_set *fdset);
```
我们分配一个fd_set数据类型的描述符集，并用这些宏设置或测试该集合中的每一位，也可以用C语言中的赋值语句把它赋值成另外一个描述符集。
```text           
    我们所讨论的每个描述符占用整数数组中一位的方法仅仅是select函数的可能实现之
一。不过把描述符集中的每个描述符中的每个描述符指称为位(bit)是常见的，例如"打开读集合中表示监
听描述符的位"。
    poll函数使用一个完全不同的表示方法，一个可变长度的结构数组，其中每个结构代表一个描述。
```
举个例子，以下代码用于定义一个fd_set类型的变量，然后打开描述符1、4和5的对应位
```c
fd_set rset;

FD_ZERO(&rset);
FD_SET(1, &rset);
FD_SET(4, &rset);
FD_SET(5, &rset);
```
描述符集的初始化非常重要，因为作为自动变量分配的一个描述符集如果没有初始化，那么可能发生不可预期的后果。           
select函数的中间三个参数readset、writeset和exceptset中，如果我们对某一个的条件不感兴趣，就可以把它设为空指针。事实上，如果这三个指针均为空，我们就有了一个比Unix的sleep函数更为精确的定时器(sleep睡眠以秒为最小单位)。poll函数提供类似的功能。      
```text
    maxfdp1参数指定待测试的描述符个数，它的值是待测试的最大描述符加1（因此我们把该
参数命名为maxfdp1），描述符0，1，2...一直到maxfdp1-1均将被测试。
```
头文件`<sys/select.h>`中定义的`FD_SETSIZE`常值是数据类型fd_set中的描述符总数，其值通常是1024，不过很少有程序用到那么多的描述符。maxfdp1参数迫使我们计算出所关心的最大描述符并告知内核该值。以前面给出的打开描述符1、4和5的代码为例，其maxfdp1值就是6。是6而不是5的原因在于，我们制定的是描述符的个数而非最大值，而描述符是从0开始的。
```text 
    存在这个参数以及计算其值的额外负担纯粹是为了效率原因。每个fd_set都有表示大量
描述符（典型数量为1024）的空间，然而一个普通进程所用的数量却少得多。内核正是通过
在进程与内核之间不复制描述符集中的不必要的部分，从而不测试总为0的那些位来提高效率的。              
```
select函数修改由指针readset、writeset和exceptset所指向的描述符集，因而这三个参数都是值-结果参数。调用该函数时，我们指定所关心的描述符的值，该函数返回时，结果将指示哪些描述符已就绪。该函数返回后，我们使用FD_ISSET宏来测试fd_set数据类型中的描述符。描述符集内任何与未就绪描述符对应的位返回时均清为0.为此，每次重新调用select函数时，我们都得再次把所有描述符集内所关心的位均置为1。         
```text
    使用select时最常见的两个编程错误是，忘了对最大描述符加1，忘了描述符集是值-结
果参数。第二个错误导致调用select时，描述符集内我们认为是1的位却被置为0。             
```
该函数的返回值表示跨所有描述符集的已就绪的总位数。如果在任何描述符就绪之前定时器到时，那么返回0。返回-1表示出错(这是可能发生的，譬如本函数被一个所捕获的信号中断)。
```text
    SVR4的早期版本中select的实现有一个缺陷，如果返回时多个描述符集内的同一位为
1，譬如说某个描述符既准备好又准备好写的情况，那么在函数返回值中只计一次。当前的
版本修正了这个缺陷。
```     
####描述符就绪条件
我们一直在讨论等待某个描述符准备好I/O（读或写）或是等待其上发生一个待处理的异常条件（带外数据）。尽管可读性和可写性对于普通文件这样的描述符显而易见，然而对于引起select返回套接字"就绪"的条件我们必须讨论得更明确些。        

* 满足下列四个条件中的任何一个时，一个套接字准备好读。     
 * 该套接字接收缓冲区中的数据字节数大于等于套接字接收缓冲区低水位标记的当前大小。对这样的套接字执行读操作不会阻塞并将返回一个大于0的值（也就是返回准备好读入的数据）。我们可以使用SO_RCVLOWAT套接字选项设置该套接字的低水位标记。对于TCP和UDP套接字而言，其默认值为1。        
 * 该连接的读半部关闭（也就是接收了FIN的TCP连接）。对这样的套接字的读操作将不阻塞并返回0（也就是返回EOF）。       
 * 该套接字是一个监听套接字且已完成的连接数不为0。对这样的套接字的accept通常不会阻塞，不过后面我们会讲解accept可能阻塞的一种时序条件。      
 * 其上有一个套接字错误待处理。对这样的套接字的读操作将不阻塞并返回-1（也就是返回一个错误），同时把errno设置成确切的错误条件。这些待处理错误（pending error）也可以通过指定SO_ERROR套接字选项调用getsockopt获取并清除。       

* 下列四个条件中的任何一个满足时，一个套接字准备好写     
 * 该套接字发送缓冲区中的可用空间字节数大于等于套接字发送缓冲区低水位标记的当前大小，并且或者该套接字已连接，或者该套接字不需要连接（如UDP套接字）。这意味着如果我们把这样的套接字设置成非阻塞，写操作将不阻塞并返回一个正值（例如由传输层接受的字节数）。我们可以使用SO_SNDLOWAT套接字选项来设置该套接字的低水位标记。对于TCP和UDP套接字而言，其默认值通常为2048。        
 * 改连接的写半部关闭。对这样的套接字的写操作将产生SIGPIPE信号。        
 * 使用非阻塞式connect的套接字已建立连接，或者connect已经以失败告终。       
 * 其上有一个套接字错误待处理。对这样的套接字的写操作将不阻塞并返回-1（也就是返回一个错误），同时把errno设置成确切的错误条件。这些待处理的错误也可以通过制定SO_ERROR套接字选项调用getsockopt获取并清除。     

* 如果一个套接字存在带外数据或者仍处于带外标记，那么它有异常条件待处理。       

注意，当某个套接字上发生错误时，它将由select标记为既可读又可写。          
接收低水位标记和发送低水位标记的目的在于，允许应用进程控制在select返回可读或可写条件之前有多少数据可读或有多大空间可用于写。举例来说，如果我们知道除非至少存在64个字节的数据，否则我们的应用进程没有任何有效工作可做，那么可以把接收低水位标记设置为64，以防少于64个字节的数据准备好读时select唤醒我们。      
任何UDP套接字只要其发送低水位标记小于等于发送缓冲区大小（默认应该总是这种关系）就总是可写的，这是因为UDP套接字不需要连接。              
下表汇总了上述导致select返回某个套接字就绪的条件
```text
|----------------------------------------------------------------------|
|  条件                       |   可读吗？  |    可写吗？   |  异常吗？|
|-----------------------------+-------------+---------------+----------|
|  有数据可读                 |      √      |               |          |
|  关闭连接的读一半           |      √      |               |          |
|  给监听套接口准备好新连接   |      √      |               |          |
|-----------------------------+-------------+---------------+----------|
|  有可用于写的空间           |             |       √       |          |
|  关闭连接的写一半           |             |       √       |          |
|-----------------------------+-------------+---------------+----------|
|  待处理错误                 |      √      |       √       |          |
|-----------------------------+-------------+---------------+----------|
|  TCP带外数据                |             |               |     √    |
|----------------------------------------------------------------------|
```
####select的最大描述符数
早些时候我们说过，大多数应用程序不会用到许多描述符。譬如说我们很少能找到一个使用几百个描述符的应用程序。然而使用那么多描述符的应用程序确实存在，它们往往使用select来复选描述符。最初设计select时，操作系统通常对每个进程可用的最大描述符数设置了上限(4.2BSD的限制为31)，select就使用相同的限制值。然而当今的Unix版本允许每个进程使用事实上无限数目的描述符(往往仅受限于内存总量和管理性限制)，因此我们的问题是，这对select有什么影响？             
许多实现有类似于下面的声明，它取自4.4BSD的`<sys/types.h>`头文件
```c
#ifndef FD_SETSIZE
#define FD_SETSIZE   256
#endif
```
这使我们想到，可以在包括该头文件之前把FD_SETSIZE定义为某个更大的值以增加select所用描述符集的大小。不幸的是，这样做通常行不通。
```text
    为了弄清楚到底出了什么差错，请注意TCPv2的图16-53声明了3个在内核中的描述符集，
并把内核的FD_SETSIZE定义作为上限使用。因此增大描述符集大小的唯一方法是先增大
FD_SETSIZE的值，再重新编译内核。不重新编译内核而改变其值是不够的。
```
```text
FD_SETSIZE常值的声明一直是在头文件<sys/types.h>中(4.4BSD和4.4BSD-Lite2)，不过更新的源自BSD的内
核和源自SVR4的内核把它改放在头文件<sys/select.h>中。值得注意的是，有些应用程序(典型例子是需要
复选大量描述符的事件驱动服务器程序，所需描述符量超过1024个)开始该用poll代替select，这样可以避
免描述符有限的问题。还要注意的是，select的典型实现在描述符数增大时可能存在扩展性问题。        
```
有些厂家正在将select的实现修改为允许进程将FD_SETSIZE定义为比默认值更大的某个值。BSD/OS已改变了内核实现以允许更大的描述符集，并定义了四个新的FD_xxx宏用于动态分配并操作这样的描述符集。然而从可移植性考虑，使用大描述符集需要小心。      


```c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <sys/select.h>
#include <sys/time.h>
#include <string.h>

void xchild()
{
	char x[] = "echo quest?\n";
	int i;
	for (i = 0; i < 5; i++) {
		sleep(1);
		write(1, x, sizeof(x));
	}
}

int main(int argc, char *argv[])
{
	pid_t pid, child;
	int fd[2];
	fd_set fds;
	struct timeval tv;
	char buf[1024];
	int flag = 0;

	FD_ZERO(&fds);
	if (pipe(fd) < 0)
		printf("pipe error\n");

	switch (pid = fork()) {
	case -1:
		printf("fork error\n");
		break;
	case 0:
		printf("child\n");
		close(fd[0]);
		xchild();
		exit(1);
	default:
		printf("parent\n");
		close(fd[1]);
		break;
	}

	for (;;) {
		tv.tv_sec = 0;
		tv.tv_usec = 0;
		FD_SET(fd[0], &fds);
		flag = select(fd[0] + 1, &fds, NULL, NULL, &tv);
		switch (flag) {
		case 0:
			printf("parent: timeout\n");
			if (errno == EOF)
				flag = -1;
			sleep(1);
			break;
		case -1:
			printf("parent error\n");
			break;
		default:
			if (FD_ISSET(fd[0], &fds)) {
				read(fd[0], buf, 1024);
				write(1, buf, strlen(buf) + 1);
			}
			break;
		}

		child = waitpid(-1, NULL, WNOHANG);
		if (child > 0) {
			printf("child pid %d exit!\n", child);
			break;
		}
	}

	return 0;
}
```


