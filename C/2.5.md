#select
该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。         
也就是说，我们调用select告知内核对哪些描述符(读、写或异常条件)感兴趣以及等待多长时间。我们感兴趣的描述符不局限于套接字，任何描述符都可以使用select来测试。           
```c
#include <sys/select.h>
#include <sys/time.h>

int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);
```
返回值，若有就绪描述符则为其数目，若超时则为0，若出错则为-1              

我们从该函数的最后一个参数timeout开始介绍，它告知内核等待所指定描述符中的任何一个就绪可花多长时间，其timeval结构用于指定这段时间的秒数和微秒数。           
```c
struct timeval {
	long tv_sec;
	long tv_usec;
};
```
这个参数有以下三种可能              
1.永远等待下去，仅在有一个描述符准备好I/O时才返回。为此，我们把该参数设置为空指针。          
2.等待一段固定时间，在有一个描述符准备好I/O时返回，但是不超过由该参数所指向的timeval结构中指定的秒数和微秒数。         
3.根本不等待，检查描述符后立即返回，这称为轮询(polling)。为此，该参数必须指向一个timeval结构，而且其中的定时器值(由该结构指定的秒数和微秒数)必须为0。          

前两种情形的等待通常会被进程在等待期间捕获的信号中断，并从信号处理函数返回。             
这意味着从可移植性考虑，如果我们在捕获信号，那么必须做好select返回EINTER错误的准备。               

如果timeval参数所指向的timeval结构中的tv_sec成员值超过1亿秒，那么有些系统的select函数将以EINVAL错误失败返回，当然这是一个非常大的超时值(超过3年)，不大可能有用，不过就此指出，timeval结构能够表达select不支持的值。          
timeout参数的const限定词表示它在函数返回时不会被select修改。举例来说，如果我们指定一个10s的超时值，不过在定时器到时之前select就返回了(结果可能是有一个或多个描述符就绪，也可能是得到EINTER错误)，那么timeout参数所指向的timeval结构不会被更新成该函数返回时剩余的秒数。如果我们需要知道这个值，那么必须在调用select之前取得系统时间，它返回后再取得系统时间，两者相减就是该值(任何健壮的程序都得考虑到系统时间可能在这段时间内偶尔会被管理员或ntpd之类守护进程调整)。              
有些Linux版本会修改这个timeval结构，因此从移植性考虑，我们应该假设该timeval结构在select返回时未被定义，因而每次调用select之前都得对它进行初始化。POSIX规定对该结构使用const限定词。             

中间的三个参数readset、writeset和exceptset指定我们要让内核测试读、写和异常条件的描述符。目前支持的异常条件只有两个              
1.某个套接字的带外数据的到达             
2.某个已置为分组模式的伪终端存在可从其主端读取的控制状态信息                

如何给这3个参数中的每一个参数指定一个或多个描述符值是一个设计上的问题。select使用描述符集，通常是一个整数数值，其中每个整数中的每一位对应一个描述符。举例来说，假设使用32位整数，那么该数组的第一个元素对应于描述符0~31，第二个元素对应于描述符32~63，依次类推。所有这些实现细节都与应用程序无关，它们隐藏在名为fd_set的数据类型和以下四个宏中
```c
void FD_ZERO(fd_set *fdset);
void FD_SET(int fd, fd_set *fdset);
void FD_CLR(int fd, fd_set *fdset);
void FD_ISSET(int fd, fd_set *fdset);
```
我们分配一个fd_set数据类型的描述符集，并用这些宏设置或测试该集合中的每一位，也可以用C语言中的赋值语句把它赋值成另外一个描述符集。           
我们所讨论的每个描述符占用整数数组中一位的方法仅仅是select函数的可能实现之一。不过把描述符集中的每个描述符中的每个描述符指称为位(bit)是常见的，例如"打开读集合中表示监听描述符的位"。               
以下代码用于定义一个fd_set类型的变量，然后打开描述符1、4和5的对应位
```c
fd_set rset;

FD_ZERO(&rset);
FD_SET(1, &rset);
FD_SET(4, &rset);
FD_SET(5, &rset);
```
描述符集的初始化非常重要，因为作为自动变量分配的一个描述符集如果没有初始化，那么可能发生不可预期的后果。           
select函数的中间三个参数readset、writeset和exceptset中，如果我们对某一个的条件不感兴趣，就可以把它设为空指针。事实上，如果这三个指针均为空，我们就有了一个比Unix的sleep函数更为精确的定时器(sleep睡眠以秒为最小单位)。      

maxfdp1参数指定待测试的描述符个数，它的值是待测试的最大描述符加1(因此我们把该参数命名为maxfdp1)，描述符0，1，2...一直到maxfdp1-1均将被测试。             

头文件`<sys/select.h>`中定义的FD_SETSIZE常值是数据类型fd_set中的描述符总数，其值通常是1024，不过很少有程序用到那么多的描述符。maxfdp1参数迫使我们计算出所关心的最大描述符并告知内核该值。以前面给出的打开描述符1、4和5的代码为例，其maxfdp1值就是6。是6而不是5的原因在于，我们制定的是描述符的个数而非最大值，而描述符是从0开始的。           
存在这个参数以及计算其值的额外负担纯粹是为了效率原因。每个fd_set都有表示大量描述符(典型数量为1024)的空间，然而一个普通进程所用的数量却少得多。内核正是通过在进程与内核之间不复制描述符集中的不必要的部分，从而不测试总为0的那些位来提高效率的。              

select函数修改由指针readset、writeset和exceptset所指向的描述符集，因而这三个参数都是值-结果参数。调用该函数时，我们指定所关心的描述符的值，该函数返回时，结果将指示哪些描述符已就绪。该函数返回后，我们使用FD_ISSET宏来测试fd_set数据类型中的描述符。描述符集内任何与未就绪描述符对应的位返回时均清为0.为此，每次重新调用select函数时，我们都得再次把所有描述符集内所关心的位均置为1。         

使用select时最常见的两个编程错误是，忘了对最大描述符加1，忘了描述符集是值-结果参数。第二个错误导致调用select时，描述符集内我们认为是1的位却被置为0。             

该函数的返回值表示跨所有描述符集的已就绪的总位数。如果在任何描述符就绪之前定时器到时，那么返回0。返回-1表示出错(这是可能发生的，譬如本函数被一个所捕获的信号中断)。           
####select的最大描述符数
早些时候我们说过，大多数应用程序不会用到许多描述符。譬如说我们很少能找到一个使用几百个描述符的应用程序。然而使用那么多描述符的应用程序确实存在，它们往往使用select来复选描述符。最初设计select时，操作系统通常对每个进程可用的最大描述符数设置了上限，select就使用相同的限制值。然而当今的Unix版本允许每个进程使用事实上无限数目的描述符(往往仅受限于内存总量和管理性限制)，因此我们的问题是，这对select有什么影响？             



