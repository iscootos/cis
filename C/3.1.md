#fopen/freopen/fdopen函数
####标准输入/标准输出和标准出错
对一个进程预定义了三个流，他们是，标准输入、标准输出和标准出错，这三个标准I/O流通过预定义文件指针stdin、stdout和stderr加以引用，这三个文件指针定义在`<stdio.h>`        
####打开流
下列三个函数打开一个标准I/O流
```c
#include <stdio.h>

FILE *fopen(const char *restrict pathname, const char *restrict type);

FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);

FILE *fdopen(int filedes, const char *type);
```
返回值，成功返回文件指针，出错返回NULL          
这三个函数的区别      
1.fopen打开一个指定的文件       
2.freopen在一个指定的流上打开一个指定的文件，如若该流已经打开，则先关闭该流。若该流已经定向，则freopen清除该定向，此函数一般用于将一个指定的文件打开为一个预定义的流，标准输入、标准输出和标准出错            
3.fdopen获取一个现有的文件描述符(我们可能从open、dup、dup2、fcntl、pipe、socket、socketpair或accept函数得到此文件描述符)，并使一个标准的I/O流与该描述符相结合。此函数常用于由创建管道和网络通信通道函数返回的描述符。因为这些特殊类型的文件不能用标准I/O fopen函数打开，所以我们必须先调用设备专用函数以获得一个文件描述符，然后用fdopen使一个标准流与该描述符相关联        

type参数指定对该I/O流的读、写方式         
r表示可读，文件必须存在         
w表示可写，如果文件不存在就创建该文件        
a表示可写，同时写入的内容在文件末尾，就是添加内容，如果文件不存在就创建该文件         
b表示二进制文件         
`+`表示可读，可写        
```text
type           说明
r或rb          以只读方式打开文件，该文件必须存在
w或wb          打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失，若文件不存在则建立该文件   
a或ab          打开一个文件，允许读或在文件末尾追加数据
r+或r+b或rb+   以只读写方式打开文件，该文件必须存在
w+或w+b或wb+   打开可读写文件，若文件存在则文件长度清为0，即该文件内容会消失，若文件不存在则建立该文件
a+或a+b或ab+   以附加方式打开可读写文件，若文件不存在，则会建立文件，如果文件存在，写入的数据会被追加到文件末尾，即文件原先的内容会被保留
```
使用字符b作为type的一部分，这使得标准I/O系统可以区分文本文件和二进制文件，因为UNIX内核并不对这两种文件进行区分，所以在UNIX系统环境下指定字符b作为type的一部分实际上并无作用          
对于fdopen，type参数的意义稍有区别。因为该描述符已被打开，所以fdopen为写而打开并不截短该文件，(例如，若该描述符原来是由open函数创建的，而且该文件那时已经存在，则其O_TRUNC标志将决定是否截短该文件，fdopen函数不能截短它为写而打开的任一文件)另外，标准I/O添写方式也不能用于创建该文件(因为如若一个描述符引用一个文件，则该文件一定已经存在)         
当用添写类型打开一个文件后，则每次写都将数据写到文件的当前尾端处。如若有多个进程用标准I/O添写方式打开了同一文件，那么来自每个进程的数据都将正确地写到文件中            

当以读和写打开一文件时(type中+符号)，具有下列限制         
如果中间没有fflush、fseek、fsetpos或rewind，则在输出的后面不能直接跟随输入        
如果中间没有fseek、fsetpos或rewind，或者一个输入操作没有到达文件尾端，则在输入操作之后不能直接跟随输出            
####关闭流
调用fclose关闭一个打开的流
```c
#include <stdio.h>

int fclose(FILE *fp);
```
返回值，若成功返回0，失败返回EOF       
在该文件被关闭之前，冲洗缓冲区中的输出数据，丢去缓冲区中的任何输入数据，如果标准I/O库已经为该流自动分配了一个缓冲区，则释放此缓冲区。           
当一个进程正常终止时(直接调用exit函数，或从main函数返回)，则所有带未写缓冲数据的标准I/O流都会被冲洗，所有打开的标准I/O流都会被关闭          
####读和写流
一旦打开了流，则可在三种不同类型的非格式化I/O中进行选择，对其进行读、写操作         
1.每次一个字符的I/O。一次读或写一个字符，如果流是带缓冲的，则标准I/O函数会处理所有缓冲         
2.每次一行的I/O。如果想要一次读或写一行，则使用fgets或fputs。每行都以一个换行符终止。当调用fgets时，应说明能处理的最大行长            
3.直接I/O。fread和fwrite函数支持这种类型的I/O。每次I/O操作读或写某种数量的对象，而每个对象具有指定的长度。这两个函数常用于从二进制文件中每次读或写一个结构           
####输入函数
以下三个函数可用于一次读一个字符      
```c
#include <stdio.h>

int getc(FILE *fp);

int fgetc(FILE *fp);

int getchar(void);
```
返回值，成功返回下一个字符，若已到达文件结尾或出错返回EOF       
函数getchar等价于`getc(stdin)`。这两个函数的区别是getc可被实现为宏，而fgetc则不能实现为宏，这意味着        
1.getc的参数不应当是具有副作用的表达式        
2.因为fgetc一定是一个函数，所以可以得到其地址，这就允许将fgetc的地址作为一个参数传送给另一个函数       
3.调用fgetc所需时间很可能长于调用getc，因为调用函数通常所需的时间长于调用宏         

这三个函数在返回下一个字符时，会将其`unsigned char`类型转换为int类型，说明为不带符号的理由是，如果最高位为1也不会使返回值为负。要求整型返回值的理由是，这样就可以返回所有可能的字符值再加上一个已出错或已到达尾端的指示值。在`<stdio.h>`中的常量EOF被要求是一个负值，其值经常是-1、这就意味着不能将这三个函数的返回值存放在一个字符变量中，以后还要将这些函数的返回值与常量EOF相比较          
注意，不管是出错还是到达文件尾端，这三个函数都返回同样的值，为了区分这两种不用的情况，必须调用ferror或feof
```c
#include <stdio.h>

int ferror(FILE *fp);

int feof(FILE *fp);
```
返回值，若条件为真则返回非0值(真)，否则返回0(假)          
```c
#include <stdio.h>

void clearerr(FILE *fp);
```
在大多数实现中，为每个流在FILE对象中维持了两个标志          
出错标志        
文件结束标志         
调用clearerr则清除这两个标志         
从流中读取数据以后，可以调用ungetc将字符再压送回流中         
```c
#include <stdio.h>

int ungetc(int c, FILE *fp);
```
返回值，若成功返回c,若出错则返回EOF        
压送回到流中的字符以后又可从流中读出，但读出字符的顺序与压送回的顺序相反。应当了解，虽然ISO C允许实现支持任何次数的回送，但是它要求实现提供一次只送回一个字符。我们不能期望一次能送回多个字符           
回送的字符不必一定是上一次读到的字符。不能回送EOF。但是当已经到达文件尾端时，仍可以回送一字符，下次读将返回该字符，再次读则返回EOF。之所以能这样做的原因是一次成功的ungetc调用会清除该流的文件结束标志        

当正在读一个输入流，并进行某种形式的分字或分记号操作时，会经常用到回送字符操作。有时需要先看一看下一个字符，以决定如何处理当前字符。然后就需要方便地将刚查看的字符送回，以便下一次调用getc时返回该字符，如果标准I/O库不提供回送能力，就需将该字符存放到一个我们自己的变量中，并设置一个标志以便判别在下一次需要一个字符时是调用getc，还是从我们自己的变量中取用           
####输出函数
对应上面的每个输入函数都有一个输出函数
```c
#include <stdio.h>

int putc(int c, FILE *fp);

int fputc(int c, FILE *fp);

int putchar(int c);
```
返回值，若成功返回c，若出错返回EOF             
与输入函数一样，putchar(c)等效于putc(c, stdout), putc可实现为宏，而fputc则不能实现为宏         
####每次一行I/O
下面两个函数提供每次输入一行的功能
```c
#include <stdio.h>

char *fgets(char *restrict buf, int n, FILE *restrict fp);

char *gets(char *buf);
```
返回值，若成功返回buf，若已到达文件结尾或出错则返回NULL          
这两个函数都指定了缓冲区的地址，读入的行将送入其中，gets从标准输入读，而fgets则从指定的流读            
对于fgets，必须指定缓冲区的长度n，此函数一直读到下一个换行符为止，但是不超过n-1个字符，读入的字符被送入缓冲区。该缓冲区以null字符结尾。如若该行(包括最后一个换行符)的字符数超过n-1，则fgets只返回一个不完整的行，但是，缓冲区总是以null字符结尾。对fgets的下一次调用会继续读该行          
gets是一个不推荐使用的函数。其问题是调用者在使用gets时不能指定缓冲区的长度。这样就可能造成缓冲区溢出(如若该行长于缓冲区长度)，写到缓冲区之后的存储空间中，从而产生不可预料的后果。这种缺陷曾被利用，造成1988年的因特网蠕虫事件。有关说明请见1989年6月发行的Communications of the ACM。gets与fgets的另一个区别是，gets并不将换行符存入缓冲区中               
即使ISO C要求实现提供gets，但请使用fgets，而不要使用gets             
fputs和puts提供每次输出一行的功能                   
```c
#include <stdio.h>

int fputs(const char *restrict str, FILE *restrict fp);

int puts(const char *str);
```
返回值，若成功则返回非负值，若出错则返回EOF           
函数fputs将一个以null符终止的字符串写到指定的流，尾端的终止符null不写出，注意着并不一定是每次输出一行，因为它并不要求在null符之前一定是换行符，通常，在null符之前是一个换行符，但并不要求总是如此         
puts将一个以null符终止的字符串写到标准输出，终止符不写出，但是，puts然后又将一个换行符写到标准输出         
puts并不像它所对应的gets那样不安全。但是我们还是应避免使用它，以免需要记住它在最后是否添加了一个换行符。如果总是使用fgets和fputs，那么就会熟知在每行终止处我们必须自己处理换行符              
####标准I/O的效率
使用getc和putc将标准输入复制到标准输出，这是从流中一个字符一个字符的读取
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
    int c;

    while ((c = getc(stdin)) != EOF) {
        if (putc(c, stdout) == EOF)
            printf("STDOUT ERROR\n");

    }

    return 0;
}
```
下面实现读、写行
```c
#include <stdio.h>

#define MAXLINE 1024

int main(int argc, char *argv[])
{
    char buf[MAXLINE];

    while (fgets(buf, MAXLINE, stdin) != NULL) {
        if (fputs(buf, stdout) == EOF)
            printf("STDOUT ERROR\n");

    }

    return 0;
}
```
上面没有显式的关闭标准I/O流，我们知道exit函数将会冲洗任何未写的数据，然后关闭所有打开的流。
