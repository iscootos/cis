#信号
信号是软件中断，信号提供了一种处理异步事件的方法。例如，终端用户键入中断键，则会通过信号机制停止一个程序，或及早终止管道中的下一个程序。          
####信号概念
首先，每个信号都有一个名字。这些名字都以三个字符SIG开头。例如，SIGABRT是夭折信号，当进程调用abort函数时产生这种信号。       
SIGALRM是闹钟信号，当由alarm函数设置的计时器超时后产生此信号。         
在头文件`<signal.h>`中，这些信号都被定义为正整数(信号编号)          
不存在编号为0的信号，kill函数对信号编号0有特殊的应用         

很多条件可以产生信号         
当用户按某些终端键时，引发终端产生的信号，在终端上按DELETE或CCTRL+C键，通常产生中断信号(SIGINT)，这是停止一个已失去控制的程序的方法             
硬件异常产生的信号，除数为0、无效的内存引用等等，这些条件通常由硬件检测到，并将其通知内核，然后内核为该条件发生时正在运行的进程产生适当的信号。例如，对执行一个无效内存引用的进程产生SIGSEGV信号           
进程调用kill(2)函数可将信号发送给另一个进程或进程组，自然，对此有所限制，接收信号进程和发送信号进程的所有者必须相同，或者发送信号进程的所有者必须是超级用户          
用户可以用kill(1)命令将信号发送给其他进程，此命令只是kill函数的接口，常用此命令终止一个失控的后台进程           
当检测到某种软件条件已经发生，并应将其通知有关进程时也产生信号。这里指的不是硬件产生的条件(如除0)，而是软件条件，例如SIGURG(在网络连接上传来带外数据时产生)、SIGPIPE(在管道的读进程已终止后，一个进程写此管道时产生)，以及SIGALRM(进程所设置的闹钟时钟)

信号是异步事件的经典实例，产生信号的事件对进程而言是随机出现的，进程不能简单的测试一个变量(如errno)来判断是否出现了一个信号，而是必须告诉内核"在此信号出现时，请执行以下操作"          
可以要求内核在某个信号出现时按照下列三种方式之一进行处理，我们称之为信号的处理或者与信号相关的动作            
1.忽略此信号，大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略，它们是SIGKILL和SIGSTOP。这两种信号不能被忽略的原因是，它们向超级用户提供了使进程终止或停止的可靠方法。另外，如果忽略某些由硬件异常产生的信号(例如非法内存引用或除以0)，则进程的运行行为是未定义的       
2.捕捉信号，为了做到这一点，要通知内核在某种信号发生时调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。例如，若正在运行一个命令解释器，它将用户的输入解释为命令并执行之，当用户用键盘产生中断信号时，很可能希望该命令解释器返回到主循环，终止正在为该用户执行的命令。如果捕捉到SIGCHLD信号，则表示一个子进程已经终止，所以此信号的捕捉函数可以调用waitpid以取得该子进程的进程ID以及它的终止状态。又例如，如果进程创建了临时文件，那么可能要为SIGTERM信号编写一个信号捕捉函数以清除临时文件(SIGTERM是终止信号，kill命令传送的系统默认信号是终止信号)。注意，不能捕捉SIGKILL和SIGSTOP信号         
3.执行系统默认动作，每一种信号有一个对应的系统默认动作，针对大多数信号的系统默认动作是终止进程           

```text
名字         说明                    默认动作
SIGABRT      异常终止(abort)         终止+core
SIGALRM      超时(alarm)             终止
SIGBUS       硬件故障                终止+core
SIGCANCEL    线程库内部使用          忽略
SIGCHLD      子进程状态改变          忽略
SIGCONT      使暂停进程继续          继续/忽略
SIGEMT       硬件故障                终止+core
SIGFPE       算术异常                终止+core
SIGFREEZE    检查点冻结              忽略
SIGHUP       连接断开                终止
SIGILL       非法硬件指令            终止+core
SIGINFO      键盘状态请求            忽略
SIGINT       终端中断符              终止
SIGIO        异步I/O                 终止/忽略
SIGIOT       硬件故障                终止+core
SIGKILL      终止                    终止
SIGLWP       线程库内部使用          忽略
SIGPIPE      写至无读进程的管道      终止
SIGPOLL      可轮询事件(poll)        终止
SIGPROF      梗概时间超时(settimer)  终止
SIGPWR       电源失败/重启动         终止/忽略
SIGQUIT      终端退出符              终止+core
SIGSEGV      无效内存引用            终止+core
SIGSTKFLT    协处理器栈故障          终止
SIGSTOP      停止                    暂停进程
SIGSYS       无效系统调用            终止+core
SIGTERM      终止                    终止
SIGTHAW      检查点解冻              忽略
SIGTRAP      硬件故障                终止+core
SIGTSTP      终端停止符              暂停进程
SIGTTIN      后台读控制tty           暂停进程
SIGTTOU      后台写至控制tty         暂停进程
SIGURG       紧急情况(套接字)        忽略
SIGUSR1      用户定义的信号          终止
SIGUSR2      用户定义的信号          终止
SIGVTALRM    虚拟时间闹钟(settimer)  终止
SIGWAITING   线程库内部使用          忽略
SIGWINCH     终端窗口大小改变        忽略
SIGXCPU      超过CPU限制(setrlimit)  终止+core/忽略
SIGXFSZ      超过文件长度限制(setrlimit)  终止+core/忽略
SIGXRES      超过资源控制            忽略
```
下面较详细地逐一说明这些信号    
######SIGABRT
调用abort函数时，产生此信号，进程异常终止        
######SIGALRM
在用alarm函数设置的计时器超时时，产生此信号，若由setitimer(2)函数设置的间隔时间超时时，也会产生此信号
######SIGBUS
指示一个实现定义的硬件故障。当出现某些类型的内存故障时，实现常常产生此种信号
######SIGCANCEL
这是Solaris线程库内部使用的信号
######SIGCHLD
在一个进程终止或停止时，将SIGCHLD信号发送给其父进程。按系统默认，将忽略此信号，如果父进程希望被告知其子进程的这种状态改变，则应捕捉此信号。信号捕捉函数中通常要调用一种wait函数以取得子进程ID和其终止状态            
######SIGCONT
此作业控制信号被发送给需要继续运行，但当前处于停止状态的进程，如果接收到此信号的进程处于停止状态，则系统默认动作是使该进程继续运行，否则默认动作是忽略此信号。例如，全屏编译器在捕捉到此信号后，使用信号处理程序发出重新绘制终端屏幕的通知
######SIGEMT
指示一个实现定义的硬件故障
######SIGPIPE
此信号表示一个算术运算异常，例如除以0，浮点溢出等
######SIGFREEZE
此信号仅由Solaris定义，它用于通知进程在冻结系统状态之前需要采取特定动作，例如当系统进入冬眠或挂起模式时可能需要执行这种处理
######SIGHUP
如果终端接口检测到一个连接断开，则将此信号发送给与该终端相关的控制进程(回话首进程)。此信号被送给session结构中的s_leader字段所指向的进程。仅当终端的CLOCAL标志没有设置时，在上述条件下才产生此信号。(如果所连接的终端是本地的，则设置该终端的COLCAL标志。它告诉终端驱动程序忽略所有调制解调器的状态行)       
注意，接到此信号的会话首进程可能在后台，例如这有别于由终端正常产生的几个信号(中断、退出和挂起)，这些信号总是传递给前台进程组           
如果会话首进程终止，则也产生此信号。在这种情况下，此信号将被发送给前台进程组中的每一个进程         
通常用此信号通知守护进程，以重新读取它们的配置文件。为此目的选用SIGHUP的理由是，守护进程不会有控制终端，而且通常决不会接收到这种信号
######SIGILL
此信号指示进程已执行一条非法硬件指令
######SIGINFO
这是一种BSD信号，当用户按状态键(一般采用Ctrl+T)时，终端驱动程序产生此信号并送至前台进程组中的每一个进程。此信号通常导致在终端上显示前台进程组中各进程的状态信息         
######SIGINT
当用户按中断键(一般采用DELETE或Ctrl+C)时，终端驱动程序产生此信号并送至前台进程组中的每一个进程。当一个进程在运行时失控，特别是它正在屏幕上产生大量不需要的输出时，常用此信号终止它。
######SIGIO
此信号指示一个异步I/O事件
######SIGIOT
这指示一个实现定义的硬件故障
######SIGKILL
这是两个不能被捕捉或忽略的信号之一。它向系统管理员提供了一种可以杀死任一进程的可靠方法
######SIGLWP
此信号由Solaris线程库内部使用，并不作一般使用
######SIGPIPE
如果在写到管道时读进程已终止，则产生此信号。当类型为SOCK_STREAM的套接字已不再连接时，进程写到该套接字也产生此信号
######SIGPOLL
当在一个可轮询设备上发生一特定事件时产生此信号
######SIGPROF
当setitimer(2)函数设置的梗概统计间隔计时器(profiling interval timer)已到期时产生此信号          
######SIGPWR
这是一种依赖于系统的信号，它主要用于具有不间断电源(UPS)的系统。如果电源失效，则UPS起作用，而且通常软件会接到通知。在这种情况下，系统依靠蓄电池电源继续运行，所以无须任何处理。但是如果蓄电池也将不能支持工作，则软件通常会再次接到通知，此时，系统必须在15~30秒内使其各部分都停止运行。此时应当发送SIGPWR信号。在大多数系统中，接到蓄电池电压过低信息的进程将信号SIGPWR发送给init进程，然后由init处理停机操作
######SIGQUIT
当用户在终端上按退出键(一般采用`Ctrl+\`)时，产生此信号，并送至前台进程组中的所有进程。此信号不仅会终止前台进程组(如SIGINT所做的那样)，同时还会产生一个core文件
######SIGSEGV
该信号指示进程进行了一次无效内存引用
######SIGSTKFLT
此信号仅由Linux定义，该信号并非由内核产生，但仍保留以向后兼容
######SIGSTOP
这是一个作业控制信号，用于停止一个进程，它类似于交互停止信号(SIGTSTP)，但是SIGSTOP不能被捕捉或忽略
######SIGSYS
该信号指示一个无效的系统调用。由于某种未知的原因，进程执行了一条机器指令，内核认为这是一个系统调用，但该指令指示系统调用类型的参数却是无效的，这种情况是可能发生的，例如，若用户编写了一道使用新系统调用的程序，然后尝试运行该程序的二进制可执行代码，而所用的操作系统却是不支持该系统调用的较早版本，于是就会出现上述情况   
######SIGTERM
这是由kill(1)命令发送的系统默认终止信号
######SIGTHAW
此信号仅由Solaris定义。当系统恢复运行被挂起的操作时，该信号用于通知相关进程，它们需要采取特殊的动作
######SIGTRAP
指示一个实现定义的硬件故障
####signal函数
```c
#include <signal.h>

void (*signal(int signo, void (*func)(int)))(int);
```
返回值，若成功则返回信号以前的处理配置，若出错则返回SIG_ERR          
signo参数是信号名            
func的值是常量SIG_IGN，常量SIG_DFL或当接到此信号后要调用的函数的地址        
如果指定SIG_IGN，则向内核表示忽略此信号(记住有两个信号SIGKILL和SIGSTOP不能忽略)        
如果指定SIG_DFL，则表示接到此信号后的动作是系统默认动作           
当指定函数地址时，则在信号发生时，调用该函数，我们称这种处理为"捕捉"该信号，称此函数为信号处理程序(signal handler)或信号捕捉函数(signal-catching function)           
signal函数原型说明此函数需要两个参数，返回一个函数指针，而该指针所指向的函数无返回值(void)，第一个参数signo是一个整数，第二个参数是函数指针，它所指向的函数需要一个整型参数，无返回值。signal的返回值是一个函数地址，该函数有一个整型参数(即最后的(int))。用自然语言来描述也就是要向信号处理程序传送一个整型参数，而它却无返回值。当调用signal设置信号处理程序时，第二个参数是指向该函数(也就是信号处理程序)的指针，signal的返回值则是指向之前的信号处理程序的指针           

####程序启动
当执行一个程序时，所有信号的状态都是系统默认或忽略，通常所有信号都被设置为它们的默认动作，除非调用exec的进程忽略该信号。确切的讲，exec函数将原先设置为要捕捉的信号都更改为它们的默认动作，其他信号的状态则不变(对于一个进程原先要捕捉的信号，当其执行一个新程序后，就自然不能再捕捉它了，因为信号捕捉函数的地址很可能在所执行的新程序文件中已无意义)            

