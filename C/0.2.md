#GCC
gcc、g++是GNU工程的C和C++的编译器          
```text
gcc[option|filename]...
g++[option|filename]...
```
C和C++编译器是集成的，它们都要用四个步骤中的一个或多个处理输入文件,预处理(preprocessing)，编译(compilation)，汇编(assembly)和连接(linking)，通过源文件的后缀名判断源文件的语言，但是对编译器来说，后缀名控制着缺省设定             
gcc 认为预处理后的文件(.i)是C文件，并且设定C形式的连接      
g++ 认为预处理后的文件(.i)是C++文件，并且设定C++形式的连接       

源文件后缀名指出语言类型以及后期的操作
```text
.c  C源程序，预处理，编译，汇编
.C  C++源程序，预处理，编译，汇编
.cc  C++源程序，预处理，编译，汇编
.cxx  C++源程序，预处理，编译，汇编
.m  Objective-C源程序，预处理，编译，汇编
.i  预处理后的C文件，编译，汇编
.ii 预处理后的C++文件，编译，汇编
.s  汇编语言源程序，汇编
.S  汇编语言源程序，预处理，汇编
.h  预处理器文件，通常不出现在命令行上
```
其他后缀名的文件被传递给连接器(linker)，通常包括
```text
.o  目标文件(Object file)
.a  归档库文件(Archive file)
```
除非使用了-c、-s或-E选项(或者编译错误阻止了完整的过程)，否则连接总是最后的步骤，在连接阶段中，所有对应于源程序的`.o`文件，`-l`库文件，无法识别的文件名(包括指定的.o目标文件和.a库文件)按命令行中的顺序传递给连接器       
总体选项(Overall Option)
```text
-c -S -E -o file -pipe -v -x language
```
######-x language
明确指出源代码文件的语言为language(而不是从文件名后缀得到的默认选择)，这个选项应用于后面所有的输入文件，直到遇着下一个`-x`选项，language的可选值有`c`、`objective-c`、`c-header`、`c++`、`cpp-output`、`assembler`、`assembler-with-cpp`         
`-x none`关闭任何对语种的明确说明，因此依据文件名后缀处理后面的文件(就像从未使用过`-x`选项)         
如果只操作四个阶段(预处理，编译，汇编，连接)中的一部分，可以使用`-x`选项(或文件名后缀)告诉gcc从哪里开始，用`-c`、`-S`、`-E`选项告诉gcc到哪里结束，注意，某些选项组合(例如,`-x cpp-output -E`)使gcc不作任何事情         
######-c
编译或汇编源文件，但是不作连接，编译器输出对于于源文件的目标文件       
缺省情况下，GCC通过用`.o`替换源文件名后缀`.c`、`.i`、`.s`等等，产生目标文件名，可以使用`-o`选项选择其他名字       
GCC忽略`-c`选项后面任何无法识别的输入文件(它们不需要编译或汇编)        
######-S
编译后即停止，不进行汇编，对于每个输入的非汇编语言文件，输出文件是汇编语言文件        
缺省情况下，GCC通过用`.o`替换源文件名后缀`.c`、`.i`等等，产生目标文件名，可以使用`-o`选项选择其他名字         
GCC忽略任何不需要编译的输入文件
######-E
预处理后即停止，不进行编译，预处理后的代码送往标准输出        
GCC忽略任何不需要编译的输入文件      
######-o file
指定输出文件为file，该选项不在乎GCC产生什么输出，无论是可执行文件，目标文件，汇编文件还是预处理后的C代码       
由于只能指定一个输出文件，因此编译多个输入文件时，使用`-o`选项没有意义，除非输出一个可执行文件        
如果没有使用`-o`选项，默认的输出结果是，可执行文件为`a.out`，`source.suffix`的目标文件是`source.o`，汇编文件是`source.s`，而预处理后的C源代码送往标准输出       
######-v
显示指向编译阶段的命令，同时显示编译器驱动程序，预处理器，编译器的版本号      
######-pipe
在编译过程的不同阶段间使用管道而非临时文件进行通信，这个选项在某些系统上无法工作，因为那些系统的汇编器不能从管道读取数据，GNU的汇编器没有这个问题        
####预处理器选项(Preprocessor Option)
下列选项对C预处理器，预处理器用于在正式编译以前，对C源文件进行某种处理        
如果指定了`-E`选项，GCC只进行预处理工作，下面的某些选项必须和`-E`选项一起才有意义，因为它们的输出结果不能用于编译        
######-E
仅运行C预处理器，预处理所有指定的C源文件，结果送往标准输出或指定的输出文件        
######-C
告诉预处理器不要丢弃注释，配合`-E`选项使用       
######-P
告诉预处理器不要产生`#line`命令，配合`-E`选项使用       
######-M [ -MG ]
告诉预处理器输出一个合适make的规则，用于描述各目标文件的依赖关系，对于每个源文件，预处理器输出一个make规则，该规则的目标项(target)是源文件对应的目标文件名，依赖项(dependency)是源文件`#include`引用的所有文件，生成的规则可以是单行，但如果太长，就用`\`换行符续成多行，规则显示在标准输出，不产生预处理过的C程序         
`-M`隐含了`-E`选项        
`-MG`要求把缺失的头文件按存在对待，并且假定它们和源程序文件在同一目录下，必须和`-M`选项一起用          
######-MM [ -MG ]
和`-M`选项类似，但是输出结果涉及用户头文件，像`#include file`忽略系统头文件如`#include <file>`       
######-MD
和`-M`选项类似，但是把依赖信息输出在文件中，文件名通过把输出文件名末尾的`.o`替换为`.d`产生，同时继续指定的编译工作，`-MD`不像`-M`那样阻止正常的编译任务        
Mach的实用工具`md`能够合并`.d`文件，产生适用于`make`命令的单一的依赖文件        
######-MMD
和`-MD`选项类似，但是输出结果仅涉及用户头文件，忽略系统头文件
######-H
除了其他普通的操作，GCC显示引用过的头文件名
######-Dmacro
定义宏macro，宏的内容定义为字符串`1`      
######-Dmaro=defn
定义宏macro的内容为defn，命令行上所有的`-D`选项在`-U`选项之前处理  
######-Umacro
取消宏macro，`-U`选项在所有的`-D`选项之后处理，但是优先于任何`-include`或`-imacros`选项
######-dM
告诉预处理器输出有效的宏定义列表(预处理结束时仍然有效的宏定义)，该选项需结合`-E`选项使用    
######-dD
告诉预处理器把所有的宏定义传递到输出端，按照出现的顺序显示
######-dN
和`-dD`选项类似，但是忽略宏的参量或内容，只在输出端显示`#define name`
####汇编器选项(ASSEMBLER OPTION)
######-Wa,option
把选项option传递给汇编器，如果option含有逗号，就在逗号处分割成多个选项
####连接器选项(LINKER OPTION)
下面的选项用于编译器连接目标文件，输出可执行文件的时候，如果编译器不进行连接，它们就毫无意义
######object-file-name
如果某些文件没有特别明确的后缀a special recognized suffix，GCC就认为它们是目标文件或库文件，(根据文件内容，连接器能够区分目标文件和库文件)，如果GCC执行连接操作，这些目标文件将成为连接器的输入文件       
######-llibrary
连接名为library的库文件     
连接器在标准搜索目录中寻找这个库文件，库文件的真正名字是`liblibrary.a`连接器会当做文件名得到准确说明一样引用这个文件       
搜索目录除了一些系统标准目录外，还包括用户以`-L`选项指定的路径          
一般说来用这个方法找到的文件是库文件，即由目标文件组成的归档文件(archive file)，连接器处理归档文件的方法是，扫描归档文件，寻找某些成员，这些成员的符号目前已被引用，不过还没有被定义，但是，如果连接器找到普通的目标文件，而不是库文件，就把这个目标文件按平常方式连接进来，指定`-l`选项和指定文件名的唯一区别是，`-l`选项用`lib`和`.a`把library包裹起来，而且搜索一些目录       
######-lobjc
这个`-l`选项的特殊形式用于连接Objective C程序
######-nostartfiles
不连接系统标准启动文件，而标准库文件仍然正常使用
######-nostdlib
不连接系统标准启动文件和标准库文件，只把指定的文件传递给连接器
######-static
在支持动态链接(dynamic linking)的系统上，阻止连接共享库，该选项在其他系统上无效      
######-shared
生成一个共享目标文件，它可以和其他目标文件连接产生可执行文件，只有部分系统支持该选项
######-symbolic
建立共享目标文件的时候，把引用绑定到全局符号上，对所有无法解析的引用作出警告(除非用连接编译选项`-Xlinker -z -Xlinker defs`取代)，只有部分系统支持该选项
####目录选项(DIRECTORY OPTION)
下列选项指定搜索路径，用于查找头文件，库文件，或编译器的某些成员
######-Idir
在头文件的搜索路径列表中添加dir目录
######-I-
任何在`-I-`前面用`-I`选项指定的搜索路径只适用于`#include "file"`这种情况，它们不能用来搜索`#include <file>`包含的头文件        
如果用`-I`选项指定的搜索路径位于`-I-`选项后面，就可以在这些路径中搜索所有的`#include`指令(一般说来-I选项就是这么用的)      
还有，`-I-`选项能够阻止当前目录(存放当前输入文件的地方)成为搜索`#include "file"`的第一选择，没有办法克服`-I-`选项的这个效应，你可以指定`-I.`搜索那个目录，它在调用编译器时是当前目录，这和预处理器的默认行为不完全一样，但是结果通常令人满意         
`-I-`不影响使用系统标准目录，因此`-I-`和`-nostdinc`是不同的选项
######-Ldir
在`-l`选项的搜索路径列表中添加dir目录
####警告选项(WARNING OPTION)
警告是针对程序结构的诊断信息，程序不一定有错误，而是存在风险，或者可能存在错误      
下列选项控制GNU CC产生的警告的数量和类型
######-fsyntax-only
检查程序中的语法错误，但是不产生输出信息
######-w
禁止所有警告信息
######-Wno-import
禁止所有关于`#import`的警告信息
######-W
对下列事件显示额外的警告信息        
非易变自动变量(nonvolatile automatic variable)可能在调用longjmp时发生改变，这些警告仅在优化编译时发生       
编译器只知道对setjmp的调用，它不可能知道会在哪里调用longjmp，事实上一个信号处理例程可以在程序的任何地点调用它，其结果是，即使程序没有问题，你也可能会得到警告，因为无法在可能出现问题的地方调用longjmp       
即可以返回值，也可以不返回值的函数(缺少结尾的函数被看作不返回函数值)，下面的函数将导致这种警告
```c
foo(a)
{
	if (a > 0)
		return a;
}
```
由于GNU CC不知道某些函数永不返回(含有abort和longjmp)，因此有可能出现虚假警告       
表达式语句或逗号表达式的左侧没有产生作用(side effect)，如果要防止这种警告，应该把未使用的表达式强制转换为void类型，例如，这样的表达式`x[i,j]`会导致警告，而`x[(void)i,j]`就不会         
无符号数用`>`或`<=`和零做比较
######-Wimplicit-int
警告没有指定类型的声明
######-Wimplicit-function-declaration
警告在声明之前就使用的函数
######-Wimplicit
同`-Wimplicit-int`和`-Wimplicit-function-declaration`
######-Wall
结合所有上述的`-W`选项，通常我们建议避免这些被警告的用法，我们相信，恰当结合宏的使用能轻易避免这些用法       
剩下的`-W...`选项不包括在`-Wall`中，因为我们认为在必要情况下，这些被编译器警告的程序结构，可以合理的用在"干净的"程序中       
######-Werror
视警告为错误，出现任何警告即放弃编译
####调试选项(DEBUGGING OPTION)
######-g
以操作系统的本地格式(stabs,COFF,XCOFF,或DWARF)，产生调试信息，GDB能够使用这些调试信息     
在大多数使用stabs格式的系统上，`-g`选项启动只有GDB才使用的额外调试信息，这些信息使GDB调试效果更好，但是有可能导致其他调试器崩溃，或拒读入程序，如果你确定要控制是否生成额外的信息，使用`-gstabs+`，`-gstabs`、`-gxcoff+`、`-gxcoff`、`-gdwarf+`、`-gdwarf`        
和大多数C编译器不同，GNU CC允许结合使用`-g`和`-O`选项，优化的代码偶尔制造一些惊异结果，某些声明过的变量根本不存在，控制流程直接跑到没有预料到的地方，某些语句因为计算结果是常量或已经确定而没有执行，某些语句在某些地方执行，因为它们被移到循环外面了        
然而它证明了调试优化的输出是可能的，对可能含有错误的程序使用优化器是合理的         

如果GNC CC支持输出多种调试信息，尽可能包括GDB扩展
######-ggdb
以本地格式(如果支持)输出调试信息，尽可能包括GDB扩展
######-gstabs
以stabs格式(如果支持)输出调试信息，不包括GDB扩展，这是大多数BSD系统上DBX使用的格式     
######-save-temps
保存那些通常是"临时"的中间文件，置于当前目录下，并且根据源文件命名，因此，用`-c -save-temps`选项编译`foo.c`会生成`foo.cpp`和`foo.s`以及`foo.o`文件
####优化选项(OPTIMIZATION OPTION)
这些选项控制多种优化措施
######-O
######-O1
优化，对于大函数，优化编译占用稍微多的时间和相当大的内存     
不使用`-O`选项时，编译器的目标是减少编译的开销，使编译结果能够调试，语句是独立的，如果在两条语句之间用断点中止程序，你可以对任何变量重新赋值，或者在函数体内把程序计数器指到其他语句，以及从源程序中精确地获取你期待的结果         
不使用`-O`选项时，只有声明了register的变量才分配使用寄存器，编译结果比不用`-O`选项的PCC要略逊一筹         
使用了`-O`选项，编译器会试图减少目标码的大小和执行时间      
如果指定了`-O`选项，`-fthread-jumps`和`-fdefer-pop`选项将被打开，在有delay slot的机器上，`-fdelayed-branch`选项将被打开，在即使没有帧指针(frame pointer)也支持调试的机器上，`-fomit-frame-pointer`选项将被打开，某些机器上还可能会打开其他选项          
######-O2
多优化一些，除了涉及空间和速度交换的优化选项，执行几乎所有的优化工作，例如不进行循环展开(loop unrolling)和函数内嵌(inlining)，和`-O`选项比较，这个选项即增加了编译时间，也提高了生成代码的运行效果
######-O3
优化的更多，除了打开`-O2`所做的一切，它还打开了`-finline-functions`选项
######-O0
不优化         

如果指定了多个`-O`选项，不管带不带数字，最后一个选项才是生效的选项        
####目标机选项(TARGET OPTION)
缺省情况下，GNU CC编译出本机类型的目标码，然而也可以把它安装成交叉编译器，为其他机器编译程序，事实上，针对不同的目标机，可以同时安装GNU CC相应的配置，然后用`-b`选项指定目标机种       
顺便提一下，新版本和旧版本的GNU CC可以共存，其中一个版本(可能是最新的那个)为缺省版本，但是有时候你希望使用其他版本     
######-b machine
参数machine指出编译的目标机种，这个选项用于安装为交叉编译器的GNU CC         
参数machine的值和配置GNU CC交叉编译器时设置的机器类型一样，例如，如果交叉编译器配置有`configure i386v`，意思是编译80386上的System V目标码，那么你可以通过`-b i386v`运行交叉编译器       
如果没有指定`-b`选项，通常指编译本机目标码        
######-V version
参数version指出运行哪个版本的GNU CC，这个选项用于安装了多个版本的GCC，例如，如果version是`2.0`，意味着运行GNU CC 2.0版          
如果没有指定`-V`选项，缺省版本取决于GNU CC的安装方式，一般说来推荐使用通用版本

####实例
无选项编译连接，将test.c预处理、汇编、编译并链接形成可执行文件，这里未指定输出文件，默认输出为`a.out`，编译成功后可以看到生成了一个`a.out`的文件，在命令行输入`./a.out`执行程序，`./`表示在当前目录，`a.out`为可执行程序文件名
```bash
gcc test.c
```

选项`-o`将test.c预处理、汇编、编译并链接形成可执行文件test，`-o`选项用来指定输出文件的文件名，输入`./test`执行程序
```bash
gcc test.c -o test
```

选项`-E`，将`test.c`预处理输出`test.i`文件
```bash
gcc -E test.c -o test.i
```

选项`-S`，将预处理输出文件`test.i`汇编成`test.s`文件
```bash
gcc -S test.i
```

选项`-c`将汇编输出文件test.s编译输出test.o文件
```bash
gcc -c test.s
```

无选项链接，将编译输出文件test.o链接成最终可执行文件test，输入`./test`执行程序
```bash
gcc test.o -o test
```

选项`-O`，使用编译优化级别2编译程序，级别为1-3，级别越大优化效果越好，但编译时间越长，输入`./test`执行程序
```bash
gcc -O2 test.c -o test
```

编译使用C++ std库，将test.cpp编译链接成test可执行文件，`-lstdc++`指定链接std c++库
```bash
gcc test.cpp -o test -lstdc++
```

多个文件一起编译，将分别将testfun.c和test.c分别编译后链接成test可执行文件
```bash
gcc testfun.c test.c -o test
```

分别编译各个源文件，之后对编译后输出的目标文件链接，`-c`只编译并生成目标文件
```bash
gcc -c testfun.c
gcc -c test.c
gcc -o testfun.o test.o -o test
```

生成共享库`.so`库文件
```bash
gcc foo.c -fPIC -shared -o libfoo.so
```

ar命令生成静态库`.a`库文件，参数c，创建一个库，不管库是否存在，都将创建，参数r,在库中插入模块(替换)，当插入的模块名已经在库中存在，则替换同名的模块，参数v，将建立库的详细的逐个文件的描述写至标准输出，参数s，同ranlib命令，生成库索引表        
```bash
ar crvs lib.a strlen.o strcat.o
```

添加头文件`-I`，例如在`/home/work/include/`目录下有编译foo.c所需头文件def.h。为了让GCC能找到它们，就需要使用`-I`选项
```bash
gcc foo.c -I /home/work/include/def.h -o foo
```

添加库文件`-L`，例如在`/home/work/lib/`目录下有链接所需库文件libdef.so，为了让GCC能找到它们，就需要使用`-L`选项,`-l`选项指示GCC去链接库文件libdef.so，linux下的库文件命名有一个约定，即库文件以lib三个字母开头，因为所有的库文件都遵循这个约定，故在用`-l`选项指定链接的库文件名时可以省去lib三个字母
```bash
gcc foo.c -L /home/work/lib -ldef.a -o foo
```

GCC默认为动态库优先，若想在动态库和静态库同时存在的时候链接静态库需要指明为-static选项
```bash
gcc foo.c -L /home/work/lib -static -ldef.a -o foo
```
####动态库
LD_LIBRAAY_PATH变量，是shell下面的动态链接库的路径
```bash
export LD_LIBRARY_PATH=/usr/local/lib
```
但是重新打开shell之前的设置就没有了          
`/etc/profile`此文件为系统的每个用户设置环境信息，当用户第一次登录时，该文件被执行，并从/etc/profile.d目录的配置文件中搜集shell的设置         
`/etc/bashrc`为每一个运行bash shell的用户执行此文件，当bash shell被打开时，该文件被读取     
`~/.bash_profile`每个用户都可使用该文件输入专用于自己使用的shell信息，当用户登录时，该文件仅仅执行一次,默认情况下，它设置一些环境变量，执行用户的`.bashrc`文件            
`~/.bashrc`该文件包含专用于你的bash shell的bash信息，当登录时以及每次打开新的shell时，该文件被读取(每个用户都有一个.bashrc文件，在用户目录下)
在以上四个文件任意一个文件的尾部，加入如下语句
```bash
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib
```
最完美的方法就是把共享库路径添加到`/etc/ld.so.conf`文件中
```bash
cat /etc/ld.so.conf
```
我们发现里面只有一句代码
```bash
include ld.so.conf.d/*.conf
```
也就是所有的共享库实际上在`/etc/ld.so.conf.d`目录下的conf文件中，所以我们在添加共享库的时候可以这样写
```bash
echo "/usr/local/mysql/lib/" >> /etc/ld.so.conf.d/mysql.conf
```
`/etc/ld.so.cache`是动态链接库的缓冲，上面我们添加了共享库，但是缓冲并没有更新，所以我们还需要使用`ldconfig`命令更新缓冲
```bash
ldconfig
```
打印缓冲中的共享库
```bash
ldconfig -p
```

####GCC环境变量
gcc找到头文件的路径
```bash
export C_INCLUDE_PATH=/usr/include/libxml2:/mylib
```
g++找到头文件的路径
```bash
export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/usr/include/libxml2:/mylib
```
动态链接库的路径
```bash
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/mylib
```
静态库的路径
```bash
export LIBRARY_PATH=$LIBRARY_PATH:/mylib
```

