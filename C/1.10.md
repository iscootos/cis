#epoll函数
头文件
```c
#include <sys/epoll.h>
```
在linux的网络编程中，很长的时间都在使用select来做事件触发。在linux新的内核中，有了一种替换它的机制，就是epoll。  相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。并且，在linux/posix_types.h头文件有这样的声明：
```c
#define __FD_SETSIZE    1024
```
表示select最多同时监听1024个fd，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。 

epoll的接口非常简单，一共就三个函数        
创建epoll fd函数
```c
int epoll_create(int size);
```

创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的 值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所 以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽

epoll_create()创建一个epoll的事例，通知内核需要监听size个fd。size指的并不是最大的后备存储设备，而是衡量内核内部结构大小的一个提示。当创建成功后，会占用一个fd，所以记得在使用完之后调用close()，否则fd可能会被耗尽。

Note:自从Linux2.6.8版本以后，size值其实是没什么用的，不过要大于0，因为内核可以动态的分配大小，所以不需要size这个提示了。

创建还有另外一个函数

```c
int epoll_create1(int flag);
```
这个函数是在linux 2.6.27中加入的，当你在看陈硕的muduo时可以看到这个函数，其实它和epoll_create差不多，不同的是epoll_create1函数的参数是flag，当flag是0时，表示和epoll_create函数完全一样，不需要size的提示了。

当flag = EPOLL_CLOEXEC，创建的epfd会设置FD_CLOEXEC

当flag = EPOLL_NONBLOCK，创建的epfd会设置为非阻塞

一般用法都是使用EPOLL_CLOEXEC.

Note:关于FD_CLOEXEC，现在网上好多都说的有点问题，我翻阅了一些资料，请教了一些人，大约明白它的意思了。

它是fd的一个标识说明，用来设置文件close-on-exec状态的。当close-on-exec状态为0时，调用exec时，fd不会被关闭；状态非零时则会被关闭，这样做可以防止fd泄露给执行exec后的进程。关于exec的用法，大家可以去自己查阅下，或者直接man exec。

epoll事件的注册函数
```c
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
```
select是在监听时告诉内核要监听的事件，而epoll_ctl是先注册需要监听的事件。

第一个参数epfd，为epoll_create返回的的epoll fd。

第二个参数op表示操作值。有三个操作类型，      
```text
EPOLL_CTL_ADD    注册新的fd到epfd中
EPOLL_CTL_MOD    修改已经注册的fd的监听事件
EPOLL_CTL_DEL    从epfd中删除一个fd    
```

第三个参数fd表示需要监听的fd。

第四个参数event表示需要监听的事件
```c
typedef union epoll_data {
void        *ptr;
int          fd;
uint32_t     u32;
uint64_t     u64;
} epoll_data_t;

struct epoll_event {
uint32_t     events;      /* Epoll events */
epoll_data_t data;        /* User data variable */
};
```
events 可以是以下几个宏的集合
```text
EPOLLIN           表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；
EPOLLOUT          表示对应的文件描述符可以写；
EPOLLPRI          表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；
EPOLLERR          表示对应的文件描述符发生错误；
EPOLLHUP          表示对应的文件描述符被挂断；
EPOLLET           将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。
EPOLLONESHOT      只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。
```
当对方关闭连接(FIN), EPOLLERR，都可以认为是一种EPOLLIN事件，在read的时候分别有0，-1两个返回值
```c
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
```
参数events用来从内核得到事件的集合，maxevents 告之内核这个events有多大，这个 maxevents 的值不能大于创建 epoll_create() 时的size，参数 timeout 是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时

EPOLL事件有两种模型 Level Triggered (LT) 和 Edge Triggered (ET)

LT(level triggered，水平触发模式)是缺省的工作方式，并且同时支持 block 和 non-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点

ET(edge-triggered，边缘触发模式)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，等到下次有新的数据进来的时候才会再次出发就绪事件

epoll等待事件函数
```c
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
int epoll_pwait(int epfd, struct epoll_event *events, int maxevents, int timeout,  const sigset_t *sigmask);
```
上面两个函数的参数含义

第一个参数:表示epoll_wait等待epfd上的事件

第二个参数:events指针携带有epoll_data_t数据

第三个参数:maxevents告诉内核events有多大，该值必须大于0

第四个参数:timeout表示超时时间(单位：毫秒)

epoll_pwait(since linux 2.6.19)允许一个应用程序安全的等待，直到fd设备准备就绪，或者捕获到一个信号量。其中sigmask表示要捕获的信号量。

函数如果等待成功，则返回fd的数字；0表示等待fd超时，其他错误号请查看errno