#管道
管道是UNIX系统IPC的最古老形式，并且所有UNIX系统都提供此种通信机制，管道有下面两种局限性     
1.它们是半双工的(即数据只能在一个方向上流动)     
2.它们只能在具有公共祖先的进制之间使用，通常，一个管道由一个进程创建，然后该进程调用fork，伺候父、字进程之间就可应用该管道            

```c
#include <unistd.h>

int pipe(int filedes[2]);
```
返回值，若成功返回0，出错返回-1         
经由参数filedes返回两个文件描述符，filedes[0]为读而打开，filedes[1]为写而打开,filedes[1]的输出就是filedes[0]的输入      
单个进程中的管道几乎没有任何用户，通常，调用pipe的进程接着调用fork，这样就创建了从父进程到子进程(或反向)的IPC通道       
调用fork之后做什么取决于我们想要有的数据流的方向。对于从父进程到子进程的管道，父进程关闭管道的读端(fd[0])，子进程则关闭写端(fd[1])       
为了构造从子进程到父进程的管道，父进程关闭fd[1]，子进程关闭fd[0]          
当管道的一端被关闭后，下列两条规则起作用       
1.当读一个写端已被关闭的管道时，在所有数据都被读取后，read返回0，以指示达到了文件结束处       
2.如果写一个读端已被关闭的管道，则产生信号SIGPIPE。如果忽略该信号或者捕捉该信号并从其处理程序返回，则write返回-1，errno设置为EPIPE          

在写管道时，常量PIPE_BUF规定了内核中管道缓冲区的大小，如果对管道调用write，而且要求写的字节数小于等于PIPE_BUF，则此操作不会与其他进程对同一管道的write操作穿插进行，但是，若有多个进程同时写一个管道，而且有进程要求写的字节数超过PIPE_BUF字节数时，则写操作的数据可能相互穿插，用pathconf或fpathconf函数可以确定PIPE_BUF的值         
