#二进制I/O
前面我们将的函数以一次一个字符或一次一行的方式进行操作，如果进行二进制I/O操作，那么我们更愿意一次读或写整个结构，如果使用getc或putc读、写一个结构，那么必须循环通过整个结构，每次循环处理一个字节，一次读或写一个字节，这会非常麻烦而且费时。如果使用fputs和fgets，那么因为fputs在遇到null字节时就停止，而在结构中可能含有null字节，所以不能使用它实现读结构的要求。类似地，如果输入数据中包含有null字节或换行符，则fgets也不能正确工作
```c
#include <stdio.h>

size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);

size_t fwrite(const void *restrict, size_t size, size_t nobj, FILE *restrict fp);
```
返回值，读或写的对象数           
这些函数有两种常见的用法         
1.读或写一个二进制数组，例如为了将一个浮点数组的第2-5个元素写至一个文件上
```c
float data[10];
if (fwrite(&data[2], sizeof(float), 4, fp) != 4)
	printf("fwrite error\n");
```
其中，指定size为每个数组元素的长度，nobj为欲写的元素数        
2.读或写一个结构
```c
struct {
	short count;
	long total;
	char name[NAMESIZE];
} item;

if (fwrite(&item, sizeof(item), 1, fp) != 1)
	printf("fwrite error\n");
```
其中，指定size为结构的长度，nobj为1(要写的对象数)         

这两个结合起来，就可读或写一个结构数组，为了做到这一点，size应当是该结构的sizeof，nobj应是该数组中的元素个数          
fread和fwrite返回读或写的对象数，对于读，如果出错或到达文件尾端，则此数字可以少于nobj。在这种情况下，应调用ferror或feof以判断究竟属于哪一种情况。对于写、如果返回值少于所要求的nobj，则出错        
