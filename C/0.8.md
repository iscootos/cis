#C语言的数据类型
整数
```text
char、short、int、long、long long
```
浮点数
```text
float、double、long double
```
逻辑
```text
bool
```
指针             
自定义类型           

类型有何不同
```text
类型名称： int、long、double
输入输出时的格式化: %d、%ld、%lf
所表达的数的范围： char < short < int < float < double
内存中所占据的大小: 1个字节到16个字节
内存中的表达形式: 二进制数(补码)、编码
```
####sizeof          
是一个运算符，给出某个类型或变量在内存中所占据的字节数
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int a;
	a = 6;
	printf("sizeof(int)=%ld\n", sizeof(int));
	printf("sizeof(a)=%ld\n", sizeof(a));
	
	return 0;
}
```
sizeof是静态运算符，它的结果在编译时刻就决定了           
不要在sizeof的括号里做运算，这些运算不会做的           
####整数
char: 1字节(8比特)         
short: 2字节          
int: 取决于编译器(CPU), 通常的意义是'1个字'             
long: 取决于编译器(CPU), 通常的意义是'1个字'       
long long: 8字节             

CPU 里面的寄存器是多少位的，如32bit,64bit，那么我们就说它是多少位宽的，同时CPU与RAM内存，传输数据的叫总线，那么它每次传输的，只能是寄存器大小的数据，然后int就是来表示寄存器大小的，所以不同计算机的int的值不一样             

####整数的内部表达式
计算机内部一切都是二进制              
```text
18  --> 00010010
0   --> 00000000
-18 --> ?
```
如何表示负数       
十进制用`-`来表示负数，在做计算的时候          
####二进制负数 
1个字节可以表达的数         
```text
00000000 -- 11111111 (0-255)
```
三种方案：           
1.仿照十进制，有一个特殊的标志表示负数         
2.取中间的数为0， 如1000000表示0, 比它小的是负数，比它大的是正数            
3.补码         

####补码
考虑`-1`，我们希望`-1 + 1 --> 0`，如何能做到?
```text
0  -->  00000000
1  -->  00000001
```
11111111 + 00000001  --> 100000000
```text
  00000001   1
+ 11111111  -1
----------------
 100000000   0
```
因为 `0 - 1 -> -1`, 所以 `-1 = (1)00000000 - 00000001 -> 11111111`            
`11111111`被当作纯二进制看待时，是255，被当作补码看待时是`-1`           
同理，对于-a， 其补码就是0-a，实际是2^n - a, n是这种类型的位数           
补码的意义就是拿补码和原码可以加出一个溢出的`0`
       
####数的范围
对于1个字节(8位)， 可以表达的是
```text
00000000 - 11111111
```            
其中         
```text
00000000 -->0
11111111 ~ 10000000 -> -1 ~ -128
00000001 ~ 01111111 -> -1 ~ 127
```
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	char c = 255;
	int i = 255;
	printf("c=%d, i=%d\n", c, i);

	return 0;
}
```
####整数的范围
char: 1字节: -128~127          
short: 字节: -32768~32768             
int: 取决于编译器(CPU)，通常的意义是`1个字`         
long: 4字节          
long long: 8字节              
大家很奇怪，为什么是-128~127呢，2^8 = 256，但是我们忽略了0这个数字，那么我们就可以知道，-2^n-1~2^n-1-1    
####unsigned
如果一个字面量常数想要表达自己是unsigned,可以在后面加u或U          
255U          
用l或L表示long(long)       
*unsigned的初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位          
整数是以纯二进制方式进行计算的，所以
```text
11111111 + 1 --> 100000000 -> 0
01111111 + 1 --> 10000000  -> -128
10000000 - 1 --> 01111111  -> 127
```
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int a = 0, b = 0;
	while (++a > 0);
	printf("int数据类型最大数是：%d\n", a - 1);

	b++;
	while ((a = a/10) !=0) 
		b++;
	printf("int数据类型最大数的数位是：%d\n", b);
	
	return 0;
}
```
####整数的输入输出
只有两种形式： int或long long       
%d: int         
%u: unsigned         
%ld: long long      
%lu: unsigned long long         
####8进制和16进制
一个以0开始的数字字面量是8进制       
一个以0x开始的数字字面量是16进制        
%o用于8进制，%x用于16进制        
8进制和16进制只是如何把数字表达为字符串，与内部如何表达数字无关           
16进制很适合表达二进制数据，因为4位二进制正好是一个16进制位        
8进制的一位数字正好表达3位二进制        
因为早期计算机的字长是12的倍数，而非8       
####浮点类型
```text
类型        字长        范围                                        有效数字
float        32         +-(1.20*10^-38~3.40*10^38),0,+-inf,nan      7
double       64         +-(2.20*10^-308~1.79*10^308),0,+-inf,nan    15
```
```text
类型     scanf    printf
float    %f       %f、%e
double   %lf      %f、%e
```
输出浮点数后三位
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	printf("%.3f\n", -0.0049);
	printf("%.30f\n", -0.0049);
	printf("%.3f\n", -0.00049);

	return 0;
}
```
####超过范围的浮点数
printf输出inf表示超过范围的浮点数: 正负无穷大          
printf输出nan表示不存在的浮点数      
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	printf("%f\n", 12.0/0.0);
	printf("%f\n", -12.0/0.0);
	printf("%f\n", 0.0/0.0);
	
	return 0;
}
```
####浮点运算的精度
带小数点的字面量是double而非float         
float需要用f或F后缀来表明身份             
```c
float a = 1.34f;
```
如果没有特殊需要，只使用double          
现代CPU能直接对double做硬件运算，性能不会比float差，在64位的机器上，数据存储的速度也不比float慢        
####字符类型
char是一种整形，也是一种特殊的类型： 字符，这是因为：        
用单引号表示的字符字面量： 'a', '1'          
''也是字符          
printf和scanf里用%c来输入输出字符             





