#open 系统调用
为了创建一个新的文件描述符，你需要使用系统调用open
```c
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

int open(const char *path,int oflags);
int open(const char *path,int oflags,mode_t mode);
```
严格来说，在遵循POSIX规范的系统上，使用open系统调用并不需要包括头文件sys/types.h和sys/stat.h,但在某些UNIX系统上，它们可能是必不可少的。

简单地说，open建立了一条到文件或设备的访问路径。如果调用成功，它将返回一个可以被read、write和其他系统调用使用的文件描述符。这个文件描述符是唯一的，它不会与任何其他运行中的进程共享。如果两个程序同时打开同一个文件，它们会分别得到两个不同的文件描述符。如果它们都对文件进行写操作，那么它们会各写各的，它们分别接着上次离开的位置继续往下写。它们的数据不会交织在一起，而是彼此互相覆盖。两个程序对文件的读写位置(偏移值)不同。你可以通过使用文件锁功能来防止出现冲突。

准备打开文件或设备的名字作为参数path传递给函数，oflags参数用于指定打开文件所采取的动作。

oflags参数是通过必需文件访问模式或其他可选模式相结合的方式来指定的。open调用必须指定下表中所示的文件访问模式之一。
```text
模式		说明
O_RDONLY 	以只读方式打开
O_WRONLY 	以只写方式打开
O_RDWR 		以读写方式打开
```
open调用还可以在oflags参数中包括下列可选模式的组合(用“按位或”操作)

O_APPEND 	:把写入数据追加在文件的末尾

O_TRUNC 	:把文件长度设置为零，丢弃已有的内容

O_CREAT 	:如果需要，就按参数mode中给出的访问模式创建文件。

O_EXCL 		:与O_CREAT一起使用，确保调用者创建出文件。Open调用是一个原子操作，也就是说，它只执行一个函数调用。使用这个可选模式可以防止两个程序同时创建同一个文件。如果文件已经存在，open调用将失败。

其他可以使用的oflags值请参考open调用的手册页。

open调用在成功时返回一个新的文件描述符(它总是一个非负整数),在失败时返回-1并设置全局变量errno来指明失败的原因。新文件描述符总是使用未用描述符的最小值，这个特征在某些情况下非常有用。例如，如果一个程序关闭了它的标准输出，然后再次调用open,文件描述符1就会被重新使用，并且标准输出将被有效地重定向到另一个文件或设备。

POSIX规范还标准化了一个creat调用，但它并不常用。这个调用不仅会像我们预期的那样创建文件，还会打开文件，。它的作用相当于以oflags标志O_CREAT|O_WRONLY|O_TRUNC来调用open。

任何一个运行中的程序能够同时打开的文件数量是有限制的。这个限制通常是由limits.h头文件中的常量OPEN_MAX定义的，它的值随系统的不同而不同，但POSIX要求它至少为16.这个限制本事还受到本地系统全局性限制的影响，所以一个程序未必总是能够打开这么多文件。在Linux系统中，这个限制可以在系统运行中调整，所以OPEN_MAX并不是一个常量。它通常一开始被设置为256。

#####访问权限的初始值
当你使用带有O_CREAT标志的open调用来创建文件时，你必须使用有3个参数格式的open调用。第三个参数mode是几个标志按(位或)后得到的，这些标志在头文件sys/stat.h中定义:
```text
S_IRUSR 	读权限，文件所有者
S_IWUSR		写权限，文件所有者
S_IXUSR 	执行权限，文件所有者
S_IRGRP 	读权限，文件所属组
S_IWGRP 	写权限，文件所属组
S_IXGRP 	执行权限，文件所属组
S_IROTH 	读权限，其他用户
S_IWOTH 	写权限，其他用户
S_IXOTH 	执行权限，其他用户
```
请看下面的例子：
```c
open("myfile",O_CREAT,S_IRUSR|S_IXOTH);
```
它的作用是创建一个名为myfile的文件，文件所有者拥有读权限，其他用户拥有执行权限，且只设置了这些权限。
```bash
ls -ls myfile
```
```text
0 -r-------x  1 root root 6448 Jan 9 09:07 myfile
```
有几个因素会对文件的访问权限产生影响。首先，指定的访问权限只有在创建文件时才会使用。其次，用户掩码(由shell的umask命令设定)会影响到被创建文件的访问权限。open调用里给出的mode值将与当时的用户掩码的反值做AND操作。举例来说，如果用户掩码被设置为001,并且指定了S_IXOTH模式标志，那么其他用户对创建的文件不会拥有执行权限，因为用户掩码中指定了不允许向其他用户提供执行权限。因此，open和creat调用中的标志实际上是发出设置文件访问权限的请求，所请求的权限是否会被设置取决于umask值。
#####umask
umask是一个系统变量，它的作用是：当文件被创建时，为文件的访问权限设定一个掩码。执行umask命令可以修改这个变量的值。它是一个由3个八进制数字组成的值。每个数字都是八进制值1、2、4的OR操作结果。它们的具体含义见下表，这3个数字分别对应着用户(user)、组(group)和其他用(other)的访问权限。
```text
数字 	取值 	含义
1 		0 		允许所有者的任何权限
		4 		禁止所有者的读权限
		2 		禁止所有者的写权限
		1 		禁止所有者的执行权限
2 		0 		允许所属组的任何权限
		4 		禁止所属组的读权限
		2 		禁止所属组的写权限
		1 		禁止所属组的执行权限
3 		0 		允许其他用户的任何权限
		4 		禁止其他用户的读权限
		2 		禁止其他用户的写权限
		1 		禁止其他用户的执行权限
```
例如，如果要禁止所属组的写和执行权限，同时禁止其他用户的写权限，那么umask值应该如下
```text
数字 		含义 		结果
1 			0			0		//数字1(0)
2			2
			1			3		//数字2(2+1=3)
3			2			2		//数字3(2)
```
每个数字的取值OR在一起，因此第2个数字的值是2|1，结果为3。最终的umask值为032。

当你通过open或creat调用创建文件时，mode参数将与当前的umask值进行比较。在mode参数中被设置的位如果在umask值中也被设置了，那么它就会从文件的访问权限中删除。因此，用户完全可以设置自己的环境，比如“不准创建允许其他用户有写权限的文件，即使创建该文件的程序要求该权限也不行。”这样做虽然并不能阻止程序或用户在随后使用chmod命令(或者在程序中使用chmod系统调用)来添加其他用户的写权限，但它确实能够帮助用户，使他们不必对每个新文件都去检查和设置其访问权限。
#####关于c语言中的umask设置
可以用下面的命令查看本机umask的值
```bash
umask
```
```text
0022
```
对应的权限是755，再去掉可执行权限111，得到644，这就是本机所有新建文件的默认权限。

我自己在用umask进行创建文件的过程中，发现所属组、其他用户的读权限默认是不让设置的，所以，最高只能设置755,再加上前面的0,得到最终的0755,如下:
```bash
rm -rf one.c one myfile
vi one.c
```
```c
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

void main()
{
	open("myfile",O_CREAT,0755);
}
```
```bash
gcc -o one one.c
./one
ls -ls myfile
```
创建文件，运行的时候输入字符，并写入文件。
```c
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>

void main()
{
	char buf[128];
	int in,out,nread;

	in=open("myfile.in",O_RDWR|O_CREAT,0755);
	out=open("myfile.out",O_RDWR|O_CREAT,0755);
	nread=read(0,buf,128);
	write(in,buf,nread);
	write(out,buf,nread);
}
```