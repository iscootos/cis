#守护进程
先来查看一些常用的系统守护进程
```bash
ps axj
```
选项a显示由其他用户所拥有的进程的状态，x显示没有控制终端的进程状态，j显示与作业有关的信息,回话ID、进程组ID、控制终端以及终端进程组ID。        
####编程规则
1.首先要做的是调用umask将文件模式创建屏蔽字设置为0，由继承得来的文件模式创建屏蔽字可能会拒绝设置某些权限。例如，若守护进程要创建一个组可读、写的文件，而继承的文件模式创建屏蔽字可能屏蔽了这两种权限，于是所要求的组可读、写就不能起作用。        
2.调用fork，然后使父进程退出(exit)，这样做实现了下面几点，第一，如果该守护进程是作为一条简单shell命令启动的，那么父进程终止使得shell认为这条命令已经执行完毕，第二，子进程继承了父进程的进程组ID，但具有一个新的进程ID，这就保证了子进程不是一个进程组的组长进程。这对于下面就要做的setsid调用是必要的前提条件      
3.调用setsid以创建一个新会话，使调用进程,(a)成为新会话的首进程，(b)成为一个新进程组的组长进程，(c)没有控制终端          
4.将当前工作目录更改为根目录，从父进程处继承过来的当前工作目录可能在一个装配文件系统中。因为守护进程通常在系统再引导之前是一直存在的，所以如果守护进程的当前工作目录在一个装配文件系统中，那么该文件系统就不能被拆卸       
5.关闭不再需要的文件描述符，这使守护进程不再持有从其父进程继承来的某些文件描述符        
6.某些守护进程打开`/dev/null`使其具有文件描述符0、1和2，这样，任何一个试图读标准输入、写标准输出或标准出错的库例程都不会产生任何效果。因为守护进程并不与终端设备相关联，所以不能在终端设备上显示其输出，也无处于交互式用户那里接收输入。即使守护进程时从交互式会话启动的，但因为守护进程是在后台运行的，所以登录会话的终止并不影响守护进程。如果其他用户在同一终端设备上登录，我们也不会在该终端上见到守护进程的输出，用户也不可期望他们在终端上的输入会由守护进程读取 
####fork函数
调用fork函数创建子进程后，使父进程立即退出，这样，产生的子进程将变成孤儿进程，并被init进程接管，同时，所产生的新进程将变为在后台运行        
```c        
#include <unistd.h>

pid_t fork(void);
```
返回值，子进程返回0，父进程中返回子进程ID，出错返回-1              
####setsid函数
调用setsid函数，使得新创建的进程脱离控制终端，同时创建新的进程组，并成功该进程组的首进程         
在linux系统中，所有的进程都属于各自的进程组，进程组是一个或多个进程的集合，打个比方，可以认为某个班级是一个进程组，而其中成员就是进程，一个班级至少一个成员，当一个班级的最后一个成员不存在的时候，这个班级也就不存在了，也就是进程组消亡了       
每个进程组都有类似于进程号的标识，称为进程组ID，进程组ID是由领头进程的进程号决定的，每个进程组都存在一个领头进程，进程组的存在与否与领头进程是否存在没有关系         
会话是一个或多个进程组的集合，与进程组类似，每个会话都存在一个领头进程，linux是一个多用户的操作系统，在同一时刻系统中会存在属于不同用户的多个进程，如果用户在某个终端上发送了某个信号，例如，按下`Ctrl+C`发送SIGINT信号，如何确保信号被正确地发送到对应的进程，同时不会影响使用其他终端的用户的进程？      
会话和进程组是Linux内核用于管理多用户情况下用户进程的方法。每个进程都属于一个进程组，而进程组又属于某个会话，当用户从终端登录系统(不管是终端还是伪终端)，系统会创建一个新的会话，在该终端上启动的进程都会被系统划归到会话的进程组中          
会话中的进程通过该会话中的领头进程(常称其为控制进程)与一个终端相连，该终端是会话的控制终端，一个会话只能有一个控制终端，反之一样，如果会话存在一个控制终端，则它必然拥有一个前台进程组，属于该组的进程可以从控制终端获得输入，这时，其他的进程组都为后台进程组          
由于守护进程没有控制终端，而使用fork函数创建的子进程继承了父进程的控制终端、会话和进程组，因此，必须创建新的会话，以脱离父进程的影响，linux系统提供了setsid函数用于创建新的会话
```c
#include <unistd.h>

pid_t setsid(void);
```
返回值，返回调用进程的会话ID，失败返回-1        
setsid函数将创建新的会话，并使得调用setsid函数的进程成为新会话的领头进程，调用setsid函数的进程时新创建会话中的唯一的进程组，进程组ID为调用进程的进程号，setsid函数产生这一结果还有个条件，即调用进程不为一个进程的领头进程，由于fork的父进程退出，使得子进程不可能是进程组的领头进程，该会话的领头进程没有控制终端与其相连，至此，满足了守护进程没有控制终端的要求      
####chdir函数
使用fork函数产生的子进程将继承父进程的当前工作目录，当进程没有结束时，其工作目录是不能被卸载的，为了防止这种问题发生，守护进程一般会将其工作目录更改到根目录`/`
```c
#include <unistd.h>

int chdir(const char *pathname);
```
返回值，成功返回0，出错返回-1       
用pathname打开文件描述符来指定新的当前工作目录       
####freopen函数
实现重定向，把预定义的标准流文件定向到由path指定的文件中，标准流文件具体是指stdin、stdout和stderr，其中stdin是标准输入流，默认为键盘，stdout是标准输出流，默认为屏幕，stderr是标准错误流，一般把屏幕设为默认
```c
#include <stdio.h>

FILE *freopen(const char *path, const char *mode, FILE *stream);
```
返回值，如果成功返回指向该stream的指针，否则NULL              
path文件名，用于存储输入输出的自定义文件名      
mode文件打开的模式，和fopen中的模式(r只读，w写)相同       
stream一个文件，通常使用标准流文件          
新产生的进程从父进程继续了某些打开的文件描述符，如果不使用这些文件描述符，则需要关闭它们。守护进程是运行在系统后台的，不应该在终端有任何的输出信息，可以使用freopen函数将标准输入、标准输出和错误输出重定向到`/dev/null`设备上(`/dev/null`是一个空设备，向其写入数据不会有任何输出)          
####umask函数
很多情况下，守护进程会创建一些临时文件，出于安全性的考虑，往往不希望这些文件被别的用户查看，这时，可以使用umask函数修改文件权限，创建掩码的取值，以满足守护进程的要求        
```c
#include <sys/stat.h>

mode_t umask(mode_t cmask);
```
umask函数为进程设置文件模式创建屏蔽字，并返回以前的值          
####Xdaemon函数
自己写的一个守护进程的函数
```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>

#include "Xsyslog.h"

void Xdaemon()
{
	pid_t pid;
	if ((pid = fork()) < 0) {
		Xsyslog("创建守护进程失败");
		exit(1);
	} else if (pid) {
		Xsyslog("父进程退出");
		exit(0);
	}
	if (freopen("/dev/null", "r", stdin) == NULL)
		Xsyslog("重定向stdin到/dev/null失败");

	setsid();
	chdir("/");
	umask(0);
	Xsyslog("启动守护进程");
}
```

