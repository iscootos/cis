#一些常用的算法
####厘米换算英尺英寸
如果已知英制长度的英尺foot和英寸inch的值，那么对应的米是(foot+inch/12)*0.3048。现在，如果用户输入的是厘米数，那么对应英制长度的英尺和英寸是多少呢？别忘了1英尺等于12英寸。               
```text
输入格式：

输入在一行中给出1个正整数，单位是厘米。

输出格式：

在一行中输出这个厘米数对应英制长度的英尺和英寸的整数值，中间用空格分开。

输入样例：
170
输出样例：
5 6
```
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int cm;
	int foot, inch;
	scanf("%d", &cm);
	inch = cm / 100.0 / 0.3048 * 12;
	foot = inch / 12;
	inch %= 12;
	printf("%d %d\n", foot, inch);

	return 0;
}
```
如上，最开始的时候，我使用`inch = cm / 100 / 0.3048 * 12`，得到的结果有问题，检查发现，是因为`cm / 100`没有使用浮点运算导致的，然后修改为`cm / 100.0`后正常            
####然后是几点
有时候人们用四位数字表示一个时间，比如1106表示11点零6分。现在，你的程序要根据起始时间和流逝的时间计算出终止时间。 读入两个数字，第一个数字以这样的四位数字表示当前时间，第二个数字表示分钟数，计算当前时间经过那么多分钟后是几点，结果也表示为四位数字。当小时为个位数时，没有前导的零，即5点30分表示为530。注意，第二个数字表示的分钟数可能超过60，也可能是负数。
```text
输入格式：

输入在一行中给出2个整数，分别是四位数字表示的起始时间、以及流逝的分钟数，其间以空格分隔。注意：在起始时间中，当小时为个位数时，没有前导的零，即5点30分表示为530；流逝的分钟数可能超过60，也可能是负数。

输出格式：

输出四位数字表示的终止时间。题目保证起始时间和终止时间在同一天内。

输入样例：
1120 110
输出样例：
1310
```
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int hour, min;
	int hours, mins;
	scanf("%d %d", &hour, &min);
	hours = hour / 100 * 60;
	mins = hour % 100 + min + hours;
	hour = mins / 60 * 100;
	min = mins % 60;
	printf("%d\n", hour + min);

	return 0;
}
```
上题，先把时间转换为分钟，再加上流逝的时间，然后得到最终时间           
####逆序的三位数
程序每次读入一个正3位数，然后输出按位逆序的数字。注意：当输入的数字含有结尾的0时，输出不应带有前导的0。比如输入700，输出应该是7。
```text
输入格式：

每个测试是一个3位的正整数。

输出格式：

输出按位逆序的数。

输入样例：
123
输出样例：
321
```
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int num;
	int x, y, z;
	scanf("%d", &num);
	x = num / 100;
	y = num % 100 / 10 * 10;
	z = num % 10 * 100;
	printf("%d", x + y + z);

	return 0;
}
```
使用除法和取余得到每个位的值，然后得到最终值         
####BCD解密
BCD数是用一个字节来表达两位十进制的数，每四个比特表示一位。所以如果一个BCD数的十六进制是0x12，它表达的就是十进制的12。但是小明没学过BCD，把所有的BCD数都当作二进制数转换成十进制输出了。于是BCD的0x12被输出成了十进制的18了！

现在，你的程序要读入这个错误的十进制数，然后输出正确的十进制数。提示：你可以把18转换回0x12，然后再转换回12
```text
输入格式：

输入在一行中给出一个[0, 153]范围内的正整数，保证能转换回有效的BCD数，也就是说这个整数转换成十六进制时不会出现A-F的数字。

输出格式：

输出对应的十进制数。

输入样例：
18
输出样例：
12
```
这个题有点绕，首先，我们要明白的就是，它要表达的意思很简单，就是二进制代码的十六进制是什么样，十进制就是什么样子的，而不应该是十进制本来的意思，所以最简单的方法就是直接输出十六进制代码就可以，或者把十进制转换为十六进制           
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int num;
	scanf("%d", &num);
	printf("%x\n", num);

	return 0;
}
```
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int num, x, y;
	scanf("%d", &num);
	x = num % 16;
	y = num / 16 * 10;
	num = x + y;
	printf("%d\n", num);

	return 0;
}
```
####用天平找小球
三个球A、B、C，大小形状相同且其中有一个球与其他球重量不同。要求找出这个不一样的球
```text
输入格式：

输入在一行中给出3个正整数，顺序对应球A、B、C的重量。

输出格式：

在一行中输出唯一的那个不一样的球。

输入样例：
1 1 2
输出样例：
C
```
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int a, b, c;
	scanf("%d %d %d", &a, &b, &c);
	if (a == b) {
		printf("C\n");
	} else if (a == c) {
		printf("B\n");
	}else {
		printf("A\n");
	}

	return 0;
}
```
该题很简单，我们用排除法，一个个排除，就得到最终的结果
####12-24小时制
编写一个程序，要求用户输入24小时制的时间，然后显示12小时制的时间
```text
输入格式：

输入在一行中给出带有中间的“:”符号（半角的冒号）的24小时制的时间，如12:34表示12点34分。当小时或分钟数小于10时，均没有前导的零，如5:6表示5点零6分。

提示：在scanf的格式字符串中加入“:”，让scanf来处理这个冒号。

输出格式：

在一行中输出这个时间对应的12小时制的时间，数字部分格式与输入的相同，然后跟上空格，再跟上表示上午的字符串“AM”或表示下午的字符串“PM”。如“5:6 PM”表示下午5点零6分。注意，在英文的习惯中，中午12点被认为是下午，所以24小时制的12:00就是12小时制的12:0 PM；而0点被认为是第二天的时间，所以是0:0 AM。

输入样例：
21:11
输出样例：
9:11 PM
```
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int hour, minute;
	scanf("%d:%d", &hour, &minute);
	if (hour < 12)
		printf("%d:%d AM\n", hour, minute);
	else if (hour == 12) {
		printf("%d:%d PM\n", hour, minute);
	}else {
		hour -= 12;
		printf("%d:%d PM\n", hour, minute);
	}

	return 0;
}
```
####成绩转换
本题要求编写程序将一个百分制成绩转换为五分制成绩。转换规则
```text
大于等于90分为A；
小于90且大于等于80为B；
小于80且大于等于70为C；
小于70且大于等于60为D；
小于60为E。
输入格式：

输入在一行中给出1个整数的百分制成绩。

输出格式：

在一行中输出对应的五分制成绩。

输入样例：
90
输出样例：
A
```
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int num;
	scanf("%d", &num);
	if (num >= 90) 
		printf("A\n");
	else if (num >= 80)
		printf("B\n");
	else if (num >= 70)
		printf("C\n");
	else if (num >= 60)
		printf("D\n");
	else
		printf("E\n");

	return 0;
}
```
####求符合给定条件的整数集
给定不超过6的正整数A，考虑从A开始的连续4个数字。请输出所有由它们组成的无重复数字的3位数
```text
输入格式：

输入在一行中给出A。

输出格式：

输出满足条件的的3位数，要求从小到大，每行6个整数。整数间以空格分隔，但行末不能有多余空格。

输入样例：
2
输出样例：
234 235 243 245 253 254
324 325 342 345 352 354
423 425 432 435 452 453
523 524 532 534 542 543
```
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int num, nums, count, i, j, k;
	scanf("%d", &num);
	count = 0;
	nums = num + 4;
	for (i = num; i < nums; i++) {
		for (j = num; j < nums; j++) {
			for (k = num ; k < nums; k++) {
				if (i != j && j != k && i != k) {
					printf("%d%d%d", i, j, k);
					count++;
					if (!(count % 6))
						printf("\n");
					else
						printf(" ");
				}
			}
		}
	}

	return 0;
}
```
或者我们也可以使用下面的方式
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int a;
	scanf("%d", &a);
	int i, j, k;
	int cnt = 0;

	int num = a + 4;
	i = a;
	while (i < num) {
		j = a;
		while (j < num) {
			k = a;
			while ( k < num) {
				if (i != j) {
					if (i != k) {
						if (j != k) {
							printf("%d%d%d", i, j, k);
							cnt++;
							if (cnt == 6) {
								printf("\n");
								cnt = 0;
							} else {
								printf(" ");
							}
						}
					}
				}
				k++;
			}
			j++;
		}
		i++;
	}

	return 0;
}
```
####前n项求和
f(n) = 1 + 1/2 + 1/3 + 1/4 + 1/5 + ... + 1/n   
因为是分子没有变化，所以我们只要循环增加分母就可以了          
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int i, n;
	double sum = 0.0;
	scanf("%d", &n);
	
	for( i = 1; i <= n; i++) {
		sum += 1.0/i;
	}
	printf("f(%d)=%f\n", n, sum);

	return 0;
}
```

f(n) = 1 - 1/2 + 1/3 - 1/4 + 1/5 + ... + 1/n         
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int i, n;
	double sum = 0.0;
	double sign = 1.0;
	scanf("%d", &n);
	
	for( i = 1; i <= n; i++) {
		sum += sign/i;
		sign = -sign;
	}
	printf("f(%d)=%f\n", n, sum);

	return 0;
}
```
如上，`-sign`第一次是负数，`--sign`第二次那么就是正数了，二把sign作为分子，所以，就是分子在翻这个数的正负极       
####整数分解
取余`% 10`， 可以得到最右边的数字          
除法`/ 10`, 可以去掉最右边的数字            
由此我们就可以实现逆序数字          
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int x, t, i;
	scanf("%d", &x);
	t = 0;
	do {
		i = x % 10;
		t = t * 10 + i;
		x /= 10;
	} while (x > 0);

	printf("t=%d\n", t);

	x = t;
	do {
		i = x % 10;
		printf("%d", i);
		if (x > 9) {
			printf(" ");
		}
		x /= 10;
	} while ( x > 0);
	printf("\n");

	return 0;
}
```
上面我们是从低位开始分解数字的，下面我们从高位来分解数字                     
取余`% 10000`，可以得到从右起前4位的数字               
除法`/ 10000`，可以得到从右起第5-n位的数字            
如上，我们可以理解为先除法，得到第5位的数字，再取余得到剩下的数字，再把`10000 / 10`，再与剩下的数字进行计算，就可以依次得到我们要的结果            
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int x;
	int mask = 10000;
	x = 12345;

	do {
		int d = x / mask;
		x %= mask;
		mask /= 10;
		printf("x = %d, mask = %d, d = %d\n",x , mask, d);
	} while (x > 0);
	printf("\n");

	return 0;
}
```
但是这里出现了一个问题，就是我们不知道输入的数字到底是几位的，那么我们通过下面的代码，来获得
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int x;
	int cnt = 0;
	scanf("%d", &x);

	do {
		x /= 10;
		cnt++;
	} while (x > 0);
	printf("cnt=%d\n", cnt);
	
	return 0;
}
```
但是我们需要的是mask,所以我们可以这样来获得
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int x;
	int mask = 1;
	scanf("%d", &x);

	do {
		x /= 10;
		mask *= 10;
	} while (x > 0);
	printf("mask=%d\n", mask);
	
	return 0;
}
```
但是，我们发现，mask多了1位，因为多跑了1轮，那么我们就少跑1轮
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int x;
	int mask = 1;
	scanf("%d", &x);

	do {
		x /= 10;
		mask *= 10;
	} while (x > 9);
	printf("mask=%d\n", mask);
	
	return 0;
}
```
但是上面的程序，在我们输入0 1 9 之内的数据的时候，还是有问题的，继续修改
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int x;
	int mask = 1;
	scanf("%d", &x);

	while ( x > 9) {
		x /= 10;
		mask *= 10;
	}
	printf("mask=%d\n", mask);
	
	return 0;
}
```
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int x, t;
	int mask = 1;
	scanf("%d", &x);
	t = x;

	while ( t > 9) {
		t /= 10;
		mask *= 10;
	}
	printf("x=%d, mask=%d\n", x, mask);

	do {
		int d = x / mask;
		printf("%d", d);
		if (mask > 9) {
			printf(" ");
		}
		x %= mask;
		mask /= 10;
	} while (mask > 0);
	printf("\n");
	
	return 0;
}
```
####求最大公约数
例如，我们要求两个数的最大公约数        
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int a, b;
	int min;
	scanf("%d %d", &a, &b);

	if (a < b) {
		min = a;
	} else {
		min = b;
	}

	int ret = 0;
	int i;
	for (i = 1; i < min; i++) {
		if (a % i == 0) {
			if (b % i == 0) {
				ret = i;
			}
		}
	}
	printf("%d和%d的最大公约数是%d.\n", a, b, ret);

	return 0;
}
```
如上，因为for循环里面只是判断了公约数的条件，所以会一直计算到它的最大值为止             
除了上面的方法我们还可以使用辗转相除法           
```text
如果b等于0, 计算结束，a就是最大公约数；
否则，计算a除以b的余数，让a等于b,而b等于那个余数；
回到第一步

a  b  t
12 18 12
18 12 6
12 6 0
6  0
```
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int a, b, t;
	scanf("%d %d", &a, &b);

	while (b != 0) {
		t = a % b;
		a = b;
		b = t;
	}
	printf("gcd = %d\n", a);

	return 0;
}
```
####水仙花数
水仙花数是指一个N位正整数（N>=3），它的每个位上的数字的N次幂之和等于它本身。例 如：153 = 13 + 53+ 33。 本题要求编写程序,计算所有N位水仙花数。
```text
输入格式：

输入在一行中给出一个正整数N（3<=N<=7）。

输出格式：

按递增顺序输出所有N位水仙花数，每个数字占一行。

输入样例：
3
输出样例：
153
370
371
407
```
所谓N次冥呢，就是乘以自己本身的次数              
而上面的N即是冥次又是数字的位数            
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int n;
	scanf("%d", &n);

	int first = 1;
	int end;
	int i = 1;
	while (i < n) {
		first *= 10;
		i++;
	}
	
	i = first;
	end = first * 10;
	while (i < end) {
		int t = i;
		int sum = 0;
		do {
			int d = t % 10;
			t /= 10;
			int p = d;
			int j = 1;
			while (j < n) {
				p *= d;
				j++;
			}
			sum += p;
		} while (t > 0);
		if (sum == i) {
			printf("%d\n", i);
		}
		i++;
	}
	return 0;
}
```
####打印九九口诀表
下面是一个完整的下三角九九口诀表：

1*1=1          
1*2=2   2*2=4              
1*3=3   2*3=6   3*3=9              
1*4=4   2*4=8   3*4=12  4*4=16             
1*5=5   2*5=10  3*5=15  4*5=20  5*5=25              
1*6=6   2*6=12  3*6=18  4*6=24  5*6=30  6*6=36             
1*7=7   2*7=14  3*7=21  4*7=28  5*7=35  6*7=42  7*7=49              
1*8=8   2*8=16  3*8=24  4*8=32  5*8=40  6*8=48  7*8=56  8*8=64                 
1*9=9   2*9=18  3*9=27  4*9=36  5*9=45  6*9=54  7*9=63  8*9=72  9*9=81                
本题要求对任意给定的1位正整数N，输出从1*1到N*N的部分口诀表。
```text
输入格式：

输入在一行中给出一个正整数N（1<=N<=9）。

输出格式：

输出下三角N*N部分口诀表，其中等号右边数字占4位、左对齐。

输入样例：
4
输出样例：
1*1=1   
1*2=2   2*2=4   
1*3=3   2*3=6   3*3=9   
1*4=4   2*4=8   3*4=12  4*4=16 
```
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int n;
	scanf("%d", &n);
	int i, j;
	i = 1;
	while (i <= n) {
		j = 1;
		while (j <= i) {
			printf("%d*%d=%d", j, i, j * i);
			if (i * j < 10) {
				printf("   ");
			} else {
				printf("  ");
			}
			j++;
		}
		printf("\n");
		i++;
	}

	return 0;
}
```
####统计素数并求和
本题要求统计给定整数M和N区间内素数的个数并对它们求和
```text
输入格式：

输入在一行中给出2个正整数M和N（1<=M<=N<=500）。

输出格式：

在一行中顺序输出M和N区间内素数的个数以及它们的和，数字间以空格分隔。

输入样例：
10 31
输出样例：
7 143
```
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int m, n;
	int i;
	int cnt = 0;
	int sum = 0;

	scanf("%d %d", &m, &n);
	if (m == 1) m = 2;
	for (i = m; i <= n; i++) {
		int isPrime = 1;
		int k;
		for (k = 2; k < i - 1; k++) {
			if (i % k == 0) {
				isPrime = 0;
				break;
			}
		}

		if (isPrime) {
			cnt++;
			sum += i;
		}
	}
	printf("%d %d\n", cnt, sum);

	return 0;
}
```
因为1不是素数，所以我们要踢掉       
####猜数字游戏
猜数字游戏是令系统随机产生一个100以内的正整数，用户输入一个数对其进行猜测，需要你编写程序自动对其与随机产生的被猜数进行比较，并提示大了（“Too big”），还是小了（“Too small”），相等表示猜到了。如果猜到，则结束程序。程序还要求统计猜的次数，如果1次猜出该数，提示“Bingo!”；如果3次以内猜到该数，则提示“Lucky You!”；如果超过3次但是在N（>3）次以内（包括第N次）猜到该数，则提示“Good Guess!”；如果超过N次都没有猜到，则提示“Game Over”，并结束程序。如果在到达N次之前，用户输入了一个负数，也输出“Game Over”，并结束程序。
```text
输入格式：

输入第一行中给出2个不超过100的正整数，分别是系统产生的随机数、以及猜测的最大次数N。随后每行给出一个用户的输入，直到出现负数为止。

输出格式：

在一行中输出每次猜测相应的结果，直到输出猜对的结果或“Game Over”则结束。

输入样例：
58 4
70
50
56
58
60
-2
输出样例：
Too big
Too small
Too small
Good Guess!
```
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int number, n;
	int inp;
	int finished = 0;
	int cnt = 0;
	scanf("%d %d", &number, &n);
	do {
		scanf("%d", &inp);
		cnt++;
		if (inp < 0) {
			printf("Game Over\n");
			finished = 1;
		} else if (inp > number) {
			printf("Too big\n");
		} else if (inp < number) {
			printf("Too small\n");
		} else {
			if (cnt == 1) {
				printf("Bingo!\n");
			} else if (cnt <= 3) {
				printf("Lucky You!\n");
			} else {
				printf("Good Guess!\n");
			}
			finished = 1;
		}
		if (cnt == n) {
			if (!finished) {
				printf("Game Over\n");
				finished = 1;
			}
		}
	} while (!finished);

	return 0;
}
```
