####单引号内的字符串直接量
单引号内的字符串直接量指的是一对单引号`'`圈引的一串字符。前后两个单引号并不属于字符串的内容，它们只是用来让perl识别字符串的开头与结尾。除了单引号和反斜线字符外，单引号内所有字符都代表它们自己(包括换行符，如果该字符串表示多行的数据的话)。要表示反斜线字符本身，需要在这个反斜线字符前再加一个反斜线字符表表示转义，要表示单引号本身时，同样在单引号前加一个反斜线字符表示转义
```pl
'fred'     #总共4个字符: f、r、r和d
'barney'   #总共6个字符
''         #空字符串(没有字符)
'/乱码'    #某些"宽"Unicode字符
'Don\'t let an apostophe end this string prematurely!'
'the last character is a backslash: \\'
'hello\n'  #hello后面接着反斜线和字母n
'hello
there'     #hello、换行符、there(总共11个字符)
'\'\\'     #单引号紧接着反斜线(总共2个字符)
```
请注意，单引号内的`\n`并不是换行符，而是表示字面上的两个字符，反斜线和字母n。只要在反斜线后面接续单引号或者反斜线时，才表示转义。
####双引号内的字符串直接量
双引号内的字符串直接量同样也是字符串序列，只不过这次换成双引号表示首尾。不过双引号中的反斜线更为强大，可以转义许多控制字符，或是用八进制或十六进制写法来表示任何字符。
```pl
"barney"          #和'barney'写法一样的效果
"hello world\n"   #hello world，后面接着换行符
"The last character of this string is a quote mark: \""
"coke\tsprite"    #coke、制表符(tab)和sprite
"\x{2668}"        #Unicode中名为HOT SPRINGS的字符的代码点(code point)
```
请注意，对perl来说双引号内的字符串直接量"barney"和单引号内的字符串直接量'barney'是相同的，都是代表那6个字符组成的字符串。一般来说，要通过反斜线转义表示换行符`\n`那样的特殊字符的话，就该用双引号书写直接量。          
反斜线后面跟上不同字符，可以表示各种不同的意义(一般我们把这种借助反斜线组合表示特殊字符的方法称作反斜线转义)。在双引号内的字符串直接量内允许使用的比较完整的转义字符清单
```text
组合        意义
\n          换行
\r          回车
\t          水平制表符
\f          换页符
\b          退格
\a          系统响铃
\e          Esc (ASCII编码的转义字符)
\007        八进制表示的ASCII值(此例中007表示系统响铃)
\x7f        十六进制表示的ASCII值(此例中7f表示删除键的控制代码)
\x{2744}    十六进制表示的Unicode代码点(这里的U+2744表示雪花形状的图形字符)
\cC         控制符，也就是Control键的代码(此例表示同时按下Ctrl键和C键的返回码)
\\          反斜线
\           双引号
\l          将下个字母转成小写的
\L          将它后面的所有字母都转为小写的，直到\E为止
\u          将下个字母转成大写的
\U          将它后面的所有字母都转为大写的，直到\E为止
\Q          相当于把它到\E之间的非单词(non word)字符加上反斜线转义
\E          结束\L、\U和\Q开始的作用范围
```
双引号内字符串的另一种特性称为变量内插，这里指在使用字符串时，将字符串内的变量名称替换为改变量当前的值。
####字符串操作符
字符串可以用`.`操作符(没错，就是句点符号)连接起来。两边的字符串都不会因此操作而被修改，就像2+3的运算不会改变2或3一样。运算后得到一个更长的字符串，可以继续用于其他运算或赋予某个变量。
```pl
"hello" . "world"        #等同于"helloworld"
"hello" . ' ' . "world"  #等同于'hello world'
'hello world'. "\n"      #等同于"hello world\n"
```
要注意的是，连接运算必须显式使用连接操作符，而不像其他某些语言只需把两个字符串放在一起就行。         
还有个比较特殊的字符串重复操作符，它其实就是一个小写字母x。此操作符会将其左边的操作数(也就是要重复的字符串)与它本身重复连接，重复次数则由右边的操作数(某个数字)指定。
```pl
"fred" x 3       #得"fredfredfred"
"barney" x (4+1) #得"barney"x5,亦即"barneybarneybarneybarneybarney"
5 x 4.8          #本质上就是"5" x 4,所以得"5555"
```
最后一个例子有必要详加说明。因为重复操作符的左操作数必然是字符串类型，所以数字5在进行重复操作前，先被转换成单字符的字符串"5"，然后这个新字符串被重复了4次，生成含有4个字符的新字符串5555。注意，如果我们将操作数对调，亦即写成4x5这样，结果会是得到重复5次的字符4，也就是44444。这说明字符串重复操作并不满足交换律。        
重复次数(右操作数)在使用前会先取整(4.8变成4)。重复次数小于1时，会生成长度为零的空字符串。
####数字与字符串之间的自动转换
通常perl会根据需要，自动在数字和字符串之间进行类型转换。那它究竟是如何指定需要数字还是字符串呢？这完全取决于操作符。如果操作符(比如+)需要的是数字，perl就会将操作数视为字符串。因此，你不必担心数字和字符串间的差异，只管合理使用操作符，perl会自动完成剩下的工作。        
对数字进行运算的操作符(比如乘法)如果遇到字符串类型的操作数，perl会自动将字符串转换成等效的十进制浮点数进行运算。因此"12"*"3"的结果会是36。字符串中非数字的部分(以及前置的空白符号)会被略过，所以"12fred34" * "3"也会得出36，，而不会出现任何警告信息。在最极端的情况下，完全不含数字的字符串会被转换成零。比如把"fred"当成数字来用就属于这种情况。          
"前置零"的技巧只对直接量有效，不能用于字符串的自动转换，自动转换总是按照十进制数字来处理的。           
```pl
0377    #十进制数字255的八进制写法
'0377'  #会转换成十进制数字377
```
同样地，需要字符串的操作符(比如字符串连接符)意外得到数字时，该数字就会被转换为形式相同的字符串。比如要把字符串Z与"5乘以7的结果"相连接，写起来非常简单         
```pl
"Z" . 5 * 7  #等同于"Z".35,得"Z35"
```
总的来说，大多数时候你根本不必关心数字和字符串的区别，perl会自动完成转换数据的工作。
####perl的内置警告信息
当发现程序有些不对劲时，可以让perl发出警告。从perl5.6开始，我们可以通过编译指令开启警告功能(但请注意，需要兼顾早期版本用户时就不能用这种方式)      
实际上，warnings编译指令能够指定代码的作用范围，warnings比-w更灵活，它可以选择只对文件中使用了该编译指令的部分代码开启警告功能，而-w选项则不加区分，对整个程序中涉及的所有代码都开启警告功能。     
```pl
#!/usr/bin/perl
use warnings;
```
也可以在命令行上使用-w选项对要运行的程序开启警告功能
```pl
perl -w my_program
```
也可以在shebang行上指定命令行选项
```pl
#!/usr/bin/perl -w
```
即便是在非Unix系统上也可以这么用，这和加不加perl的具体路径没关系，一般都会写成
```pl
#!perl -w
```
现在，如果你把'12fred34'当数字用，perl就会发出警告
```text
Argument "12fred34" isn't numeric
```
虽然发出了警告，但perl仍然会按照它既定的默认规则，把非数字字符串'12fred34'转换为12。          
当然，警告信息通常是给程序员看的，而不是最终用户。要是连程序员都不看的话，警告信息大概也没什么用。另外，警告信息并不会改变程序的行为，只会让它偶尔抱怨几声。如果看不懂某个警告信息，可以利用diagnostics这个编译命令报告更为详尽的问题描述。在perldiag文档中列有简要警告信息和详细诊断说明，该文档是理解diagnostics输出信息的最佳参考
```pl
#!/usr/bin/perl
use diagnostics;
```
在把use diagnostics这个编译指令加进程序之后，你可能会觉得程序启动好像有点慢。这是因为程序正在忙着加载警告和详细说明到内存，准备好碰到有错误或警告发送，就立即输出相关的错误信息。其实反过来看，这也提示了一种优化程序的方法，如果熟悉各种警告信息的意义，就不必在运行时发出详细的警告解释，去掉use diagnostics这个编译命令就会让程序启动变快，内存消耗也随之减少。(当然，如果能修改好程序，让它不再产生烦人的警告信息，就再好不过了。或者干脆直接关闭警告信息。)        
更进一步，这种优化也可以通过perl的命令行选项-M来实现。与其每次修改程序代码，不如仅在需要时加载diagnostics编译命令         
如果程序用到别人写的模块，那么警告同样会作用于这些模块中的代码，所以使用这种方式也许会看到别人的代码的警告。
```text
perl -Mdiagnostics ./my_program
Argument "12fred34" isn't numeric in addition (+) at ./my_program line 17 (#1)
(W numeric) The indicated string was fed as an argument to an operator that expecteda numeric value instead.If you're fortunate the message will identify which operator was so unfortunate.
```
注意警告信息中出现的(W numeric)，其中W的意思是警告级别属于普通警告，numeric的意思是警告类型属于数字操作一类。所以，看到这两条就知道潜在问题大致出在哪里。        