####if控制结构
学会如何比较两个值后，你可能需要根据比较结果决定下一步流程，perl和所有同类型的程序语言一样，也具备if条件语句控制结构
```pl
if ($name gt 'fred') {
	print "'$name' comes after 'fred' in sorted order.\n";
}
```
如果要在条件不符时做别的处理，可以使用else关键字
```pl
if ($namegt'fred') {
	print "'$name' comes after 'fred' in sorted order.\n";
} else {
	print "'$name' does not come after 'fred'.\n";
	print "Maybe it's the same string, in fact.\n";
}
```
条件语句中的代码块周围一定要加上表示界限的花括号，这点和C语言不同。你最好和上面一样，将代码块里的内容向里缩排，这样程序读起来会方便许多。如果你用的是专为程序员设计的编辑器，这类事情可以由它完成。     
####布尔值
其实，任何标量值都可以成为if控制结构里的判断条件。如果把表达式返回的真假值保存到变量中，那么在判断时可以直接检查该变量的值，读起来也更方便。         
```pl
$is_bigger = $name gt 'fred';
if ($is_bigger) {...}
```
但Perl是如何决断给定值的真假呢？和其他语言不同，perl并没有专用的布尔(Boolean)数据类型，它是靠一些简单的规则来判断的。       
如果是数字，0为false, 所有其他数字为true       
如果是字符串，空字符串('')为false，所有其他字符串都为true         
如果即不是数字也不是字符串，那就先转换成数字或字符串再行判断。undef表示假                   
其实上面的规则中还隐含着一个技巧。字符串`'0'`跟数字0是同一个标量值，所以perl会将他们一视同仁。也就是说，字符串`'0'`是唯一被当成假的非空字符串。          
要取得任何布尔值的相反值，可以用`!`这个单目取反操作符。若它后面的操作数为真，就返回假，若后面的操作数为假，则返回真。       
```pl
if (!$is_bigger) {
	# 如果$is_bigger不为真，则执行这里的代码
}
```
这里还有一个小技巧，由于`!`会颠倒真假值，并且perl又没有专门的布尔类型的变量，所以`!`总是会返回某个代表真假的标量值。而数字1和undef都是非常自然的表示真假的标量值，所以人们常常喜欢把布尔值归一化到这两个值来表示。转换过程只是利用了连续两次的`!`反转操作，得到表示布尔值的变量
```pl
$still_true = !! 'Fred';
$still_false = !! '0';
```
不过，相关文档中从未说明一定就是返回1或undef，但我们觉得将来也应该不会有变化。
####获取用户输入
此刻，你大概已经相当好奇，该如何让perl程序读取从键盘输入的值？最简单的方式就是使用"行输入" 操作符`<STDIN>`       
只要把`<STDIN>`放在程序中希望返回标量值的位置上，perl就会从标准输入(standard input)读取一行文本(直到换行符为止)。标准输入可以有多种意义，但除非另外设定为其他输入来源，否则默认就是调用程序的用户(多半就是你)手边的键盘。如果`<STDIN>`里没有可供读取的字符(一般都是如此，输入缓存区没有任何数据，除非你在程序启动期间预先打了一整行字符)，perl程序就会停下来，等待你输入某些字符，直到看见换行符(即按下回车键)为止。           
由`<STDIN>`返回的字符串一般在末尾都会带有换行符。所以，通过下面这段代码，我们可以看到实际发生的情况
```pl
$line = <STDIN>;
if ($line eq "\n") {
	print "That was just a blank line!\n";
} else {
	print "That line of input was: $line";
}
```
不过实际编写代码时，很少需要保留末尾换行符，所以人们常常会用chomp()操作符去掉它。       
####chomp操作符
咋看之下，chomp()操作符的用途好像太过简单专一，只能作用于单个变量，且该变量的内容必须为字符串，如果该字符串末尾是换行符，chomp()的任务就是去掉它。差不多这就是它所有的工作了。
```pl
$text = "a line of text\n";   #或者从<STDIN>读进来
chomp($text);                 #去除行末的换行符
```
其实它还是非常有用的，你以后写的每个程序几乎都少不了它。如上所示，处理字符串变量时，它是去除行末换行符的最佳方式。事实上，chomp()还有一种取巧的用法，因为perl有一条规则，任何需要变量的地方，都可以用赋值运算表达式代替。实际上perl会先做赋值运算，然后返回赋值后的变量，所以chomp()最常见的用法就是连用。         
```pl
chomp($text = <STDIN>);  #读入文字，略过最后的换行符
$text = <STDIN>;   #做同样的事....
chomp($text);      #...却分成两步
```
咋看之下好像采用合并方式的chomp()写起来并不轻松，反而显得更复杂！如果把它看作两次操作(读取一行文字，再对它做chomp())，那么分两步写确实比较自然。但如果将它看作一次操作(只读取文字，不含换行符)，那么合并的写法就更自然了。许多perl程序员都倾向于使用这种写法，所以现在你也该开始习惯起来。            
其实，chomp()本质上是函数。而作为一个函数，它就有自己的返回值。chomp()函数的返回值是实际移除的字符数。这个数字几乎没有用处。           
这里有个例外，那就是标准输入流在读入行期间突然中止了。可是，不以换行符结尾的文件当然不能算是正常的文本文件。           
```pl
$food = <STDIN>;
$betty = chomp $food;  #会得到返回值1  不过我们早知道了
```
正如你所见，使用chomp()时，可以加上括号，也可以不加。这是perl的另一项惯例，除非去掉括号会改变表达式的意义。否则括号可以省略           
如果字符串后面有两个以上的换行符，chomp()仅仅删除一个，如果结尾处没有换行符，它什么也不做，直接返回零。          
####while控制结构
perl和大部分用来实现算法的语言一样，也有好几种循环结构。在while循环中，只要条件持续为真，就会不断执行代码块
```pl
$count = 0;
while ($count < 10) {
	$count += 2;
	print "count is now $count\n";  #依次打印值 2 4 6 8 10
}
```
这里的真假值与之前提到的if条件测试里的真假值定义相同。代码块外围的花括号也和if控制结构的一样必不可少。条件表达式在第一次执行代码块之前就会被求值，所以如果它一开始就为假，里面的循环就会被直接略过。         
####undef值
如果还没赋值就用到了某个标量变量，会有什么结果呢？答案是，不会发生什么大不了的事，也绝对不会让程序中止运行。在首次赋值前，变量的初始值就是特殊的undef(未定义)值，它在perl里的意思仅仅是，这里空无一物，如果你想把这个"空无一物"当成数字使用，它就会表现得像零，如果当成字符串使用，它就会表现得像空字符串。但undef即不是数字也不是字符串，它完全是另一种类型的标量值。       
既然undef作为数字时会被视为零，我们可以很容易地构造一个数字累加器，它在开始时是空的
```pl
#累加一些奇数
$n = 1;
while ($n < 10) {
	$sum += $n;
	$n += 2;  #准备下一个奇数
}
print "The total was $sum.\n";
```
在循环开始之前，$sum的初始值是undef，但这并不妨碍程序的运行。当第一次执行循环时，$n的值是1，所以循环里的第一行会将$sum的值加1。这么做，如果将现值为0的变量加1(因为我们把undef当成数字用)，所以累加的值会变成1。此后它已经被初始化了，所以就能按常规方式累加。       
同样的道理，也可以做出一个字符串累加器，它在一开始时是空的
```pl
$string .= "more text\n";
```
如果$string的初始值是undef，它在这里就会被当成空字符串处理，变量的值被设为"moretext\n"。如果它里面已经有字符串，就会把新的文字追加在后面。         
perl程序员常常根据需要把新变量当作零或空字符串来用。         
许多操作符在参数越界或不合理时会返回undef。除非有特别处理，否则就会返回零或空字符串。实际上这并不代表有什么大问题，而且有很多程序员就是靠这种特性来写程序的。但你改知道的是，在警告信息开启时，perl通常会对未定义值的危险用法发出警告，因为那可能就是程序里的缺陷。举例来说，复制某个undef的变量到另一个变量没有什么问题，但若要用print将它输出就会引发警告信息。            





