#命令的执行
编写脚本程序时，你经常需要捕获一条命令的执行结果，并把它用在shell脚本程序中。也就是说，你想要执行一条命令，并把该命令的输出放到一个变量中。 	

你可以用在本章前面set命令示例中介绍的`$(command)`语法来实现，也可以用一种比较老的语法形式`command`，这种用法目前依然很常见。 			

请注意，在脚本程序里执行命令的比较老的语法形式时，使用的是反引号\`，而不是我们在前面使用的单引号`'`单引号的作用是防止变量扩展）。只有当你需要使自己的脚本程序具备非常好的可移植性时，你才应该使用这种比较老的方法。 			

所有的新脚本程序都应该使用`$(...)`形式，引入这一形式的目的是为了避免在使用反引号执行命令时，处理其内部的`$`、\`、`\`等字符所需要应用的相当复杂的规则。如果在反引号`...`结构中需要用到反引号，它就必须通过\字符进行转义。这些相对晦涩的字符往往会让程序员感到困惑，有时即使是经验丰富的shell脚本程序员也必须反复进行实验，才能确保在反引号命令中引号的使用不会出错。 	

`$(command)`的结果就是其中命令的输出。注意，这不是该命令的退出状态，而是它的字符串形式的输出结果。例如： 			
```bash
#!/bin/sh
echo The current directory is $PWD
echo The current users are $(who)

exit 0
```
因为当前目录是一个shell环境变量，所以程序的第一行不需要使用这个命令执行结构。但如果我们想要在脚本程序中使用who命令的输出结果，就需要使用这个结构。

如果想要将命令的结果放到一个变量中，你可以按通常的方法来给它赋值，如下所示：
```bash
whoisthere=$(who)
echo $whoisthere
```
这种把命令的执行结果放到变量中的能力是非常强大的，它使得在脚本程序中使用现有命令并捕获其输出变得很容易。如果需要把一条命令在标准输出上的输出转换为一组参数，并且将它们用做为另一个程序的参数，你会发现命令xargs可以帮你完成这一工作。具体细节请参考它的手册页。

有时，当你打算调用的命令在输出你想要的内容之前先输出了一些空白字符，或者它输出的内容比你想要的要多的时候也会出现问题。此时，你可以用前面介绍的set命令来解决。

##### 算术扩展
你已经见过形式最简单的参数赋值和扩展了，如下所示：
```bash
foo=fred
echo $foo
```
但当你想在变量名后附加额外的字符时就会遇到问题。假设你想编写一个简短的脚本程序，来处理名为1_tmp和2_tmp的两个文件。你可能会这样写：
```bash
#!/bin/sh
for i in 1 2
do
	my_secret_process $i_tmp
done
```
但是在每次循环中，你都会看到如下所示的出错信息：
```text
my_secret_process: too few arguments
```
哪里出错了呢？

问题在于shell试图替换变量$i_tmp的值，而这个变量其实并不存在。shell并不会认为这是一个错误，仅仅会将它替换为一个空值，因此根本不会有参数被传递给my_secret_process。为了保护变量名中类似于$i部分的扩展，你需要把i放在花括号中，如下所示：

```bash
#!/bin/sh
for i in 1 2
do 
	my_secret_process ${i}_tmp
done
```
在每次循环中，变量i的值替换了$(i),从而给出正确的文件名。也就是说，你把参数的值替换进了一个字符串。

你可以在shell中采用多种参数替换方法。对于多参数处理问题来说，这些方法通常会提供一种精巧的解决方案。下表列出了一些常见的参数扩展方法。

```text
参数扩展 				说明
${param:-default} 		如果param为空，就把它设置为default的值
${#param} 				给出param的长度
${param$word} 			从param的尾部开始删除与word匹配的最小部分，然后返回剩余部分
${param%%word} 			从param的尾部开始删除与word匹配的最长部分，然后返回剩余部分
${param#word} 			从param的头部开始删除与word匹配的最小部分，然后返回剩余部分
${param##word} 			从param的头部开始删除与word匹配的最长部分，然后返回剩余部分
```
当处理字符串时，这些替换通常是很有用的。特别是上表中对字符串进行部分删除的最后4个参数扩展方法，在处理文件名和路径时非常有用，请看下面的例子。

下面脚本程序的各个部分分别演示了各种参数匹配操作符的用法
```bash
#!/bin/sh
unset foo
echo ${foo:-bar}

foo=fud
echo ${foo:-bar}

foo=/usr/bin/X11/startx
echo ${foo#*/}
echo ${foo##*/}

bar=/usr/local/etc/local/networks
echo ${bar%local*}
echo ${bar%%local*}

exit 0
```
```text
bar
fud
usr/bin/X11/startx
startx
/usr/local/etc
/usr
```
第一条语句${foo:-bar}给出的值是bar，这是因为在这条语句执行时foo没有值。这条语句执行后，变量foo未发生变化，它还停留在未设置状态。

如果这条语句是${foo:＝bar}，那么变量$foo就会被赋值。这个字符串操作符的作用是，检查变量foo是否存在且不为空。如果它不为空，就返回它的值，否则就把变量foo赋值为bar并返回这个值。

${foo:?bar}语句将在变量foo不存在或它设置为空的情况下，输出foo:bar并异常终止脚本程序。最后，${foo:+bar}语句将在变量foo存在且不为空的情况下返回bar。选择可太多了！

{foo#*/}语句仅仅匹配并删除最左边的/（记住，*匹配零个或多个字符）。{foo##*/}语句匹配并删除尽可能多的字符，所以它删除最右边的/及其前面的所有字符。

{bar%local*}语句匹配从右边起直到第一次出现local（及跟在它后面的所有字符），而{bar%%local*}语句则从右边起尽可能多地匹配字符，直到遇到最靠左边的local。

因为UNIX和Linux系统都非常依赖过滤器的思想，所以一个操作的结果常常必须手工进行重定向。假设你想使用cjpeg程序将一个GIF文件转换为一个JPEG文件：

```bash
cjpeg image.gif > image.jpg
```
但有时，你可能希望对大量文件执行这类操作，那么如何实现自动重定向呢？很简单，像下面这样做即可：
```bash
#!/bin/sh
for image in *.gif
do
	cjpeg $image > ${image%%gif}jpg
done
```
这个脚本名为giftojpeg，它为当前目录中的每个GIF文件创建一个对应的JPEG文件。
