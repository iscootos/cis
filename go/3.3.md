#数组
创建数组,声明数组
```go
//var 数组名称 [数组的长度]存储元素的类型
var a [10]int
```
```go
var b [10]int //声明了一个int类型的数组
b[0] = 42     //数组下标是从0开始
b[2] = 50     //赋值操作
fmt.Println("数组b的第一个值是：%d\n",b[0])    //获取数据，返回42
fmt.Println("数组b的最后一个值是：%d\n",b[9])  //返回未赋值的最后一个元素，默认返回0
```
```go
// 声明一个含有10个元素元素类型为byte的数组
var ar = [10]byte {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}

// 声明两个含有byte的slice
var a, b []byte

// a指向数组的第3个元素开始，并到第五个元素结束，
a = ar[2:5]
//现在a含有的元素: ar[2]、ar[3]和ar[4]

// b是数组ar的另一个slice
b = ar[3:5]
// b的元素是：ar[3]和ar[4]
```
由于长度也是数组类型的一部分，因此[3]int与[4]int是不同的类型，数组也就不能改变长度。
数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是改数组的副本，而不是它的指针。
如果使用指针，那么就需要用到后面介绍的slice类型了。
数组可以使用另外一种`:=`来声明。
```go
a := [3]int{1,2,3}  //声明了一个长度为3的int数组
b := [10]int{1,2,3} //声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其他默认为0
c := [...]int{4,5,6} //可以省略长度而采用`...`的方式，Go 语言会自动根据元素个数来计算
```
也许你会说，我想数组里面的值还是数组，Go语言支持嵌套数组，即多维数组。
```go
//声明了一个二维数组，改数组以两个数组为元素，其中每个数组中有个4个int类型的元素。
a := [2][4]int{[4]int{1,2,3,4},[4]int{5,6,7,8}}

//如果内部的元素和外部的一样，那么上面的声明可以简化，直接忽略内部的类型
a := [2][4]int{{1,2,3,4}{5,6,7,8}}
```
```go
var a [2]int
var c [3]string
```
声明并赋值
```go
x:=[10]int{}
m[1]=2
```
new关键字创建数组
```go
x:=new([10]int)
n[0]=2
```
指定地d[19]的值是1，d数组的长度是20，所以前面的都有0填充。
```go
d:=[20]int{19:1}
```
输出
```text
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1]
```
[...]为动态数组，可以自动调整数组长度,{}里面的值都几个，长度就是几个。
```go
x:=[...]int{1,2,3,4,5}
```
输出
```text
[1 2 3 4 5]
```
指定动态数组的KEY和VALUE
```go
x:=[...]int{0:1,1:2,2:3}
```
输出
```text
[1 2 3]
```
数组指针,数组长度10(0-9),指针长度10(1-10),y的数组指针，存储的是x数组的地址
```go
x:=[...]int{99:1}
var y *[100]int=&x
fmt.Println(*y)
```
输出
```text
[0 0 0 0 0 0 0 0 0 1]
[0 0 0 0 0 0 0 0 0 1]
```
动态数组类型指针，数组里面存储的是指针地址
```go
x,y:=1,2
z:=[...]*int{&x,&y}
fmt.Println(z)
fmt.Println(*z[0],*z[1])
```
输出
```text
[0xc084000038 0xc084000040]
1 2
```
#####数组比较
```go
x:=[2]int{1,2}
y:=[2]int{1,2}
fmt.Println(x==y)
```
输出
```text
true
```
#####多维数组
```go
x:=[2][3]int{{1,1,1},{2,2,2}}
```
输出
```text
[[1 1 1] [2 2 2]]
```
#####
```go
v := [...]int{5, 2, 6, 3, 9}
    fmt.Println(v)

    num := len(v)
    for i := 0; i < num; i++ {
        for j := i + 1; j < num; j++ {
            if v[i] < v[j] {
                temp := v[i]
                v[i] = v[j]
                v[j] = temp
            }

        }
    }
    fmt.Println(v)
```
#####遍历数组
for配合range可以用于读取slice和map的数据：
```go
for k,v:=range map {
    fmt.Println("map's key:",k)
    fmt.Println("map's val:",v)
}
```
```go
arr := []int{1,2,3,4,5,6,7,8,9,0}
for k,v := range arr {
    fmt.Println(k,v)
}
```
由于 Go 支持 “多值返回”, 而对于“声明而未被调用”的变量, 编译器会报错, 在这种情况下, 可以使用_来丢弃不需要的返回值 例如
```go
for _, v := range map{
    fmt.Println("map's val:", v)
}
```
#####给数组添加内容
```go
arr := []int{}
for i = 1; i < 100; i++ {
    arr = append(arr,i)
    fmt.Println(arr)
}
fmt.Println(arr)
```
