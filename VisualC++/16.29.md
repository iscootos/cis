#SQLite 数据库
SQLite 数据库是一个纯C语言的嵌入式数据库              
讲下为什么样要用这个，因为在做一个MFC程序开发的时候，需要记住用户输入的用户名和密码             
CRegKey操作注册表需要管理员权限，但有时候客户没有管理员权限就没办法操作了         
后来又想用jsoncpp和libjson库来操作json文件，jsoncpp编译后对于std::istream这块不太懂，就没折腾了            
libjson倒是纯C的，问题是在MFC上面编译后，静态引用的时候，问题很多，包括lib文件有5M多，我嫌太大，就直接放弃了              
最后就想起了，SQLite           
[http://www.sqlite.org/](http://www.sqlite.org/)

###编译安装
我下载的Source Code的amalgamation版         
一共4个文件，我直接新建了一个静态库项目把这4个文件，导入后，生成了静态库，然后导入MFC程序

```cpp
#include ".\sqlite\sqlite3.h"
#pragma comment(lib, ".\\sqlite\\sqlite.lib")
```
###打开数据库
```cpp
int sqlite3_open(
  const char *filename,   /* Database filename (UTF-8) */  /* 数据库文件路径(UTF-8编码) */
  sqlite3 **ppDb          /* OUT: SQLite db handle */  /* 输出: SQLite 数据库句柄 */
);
int sqlite3_open16(
  const void *filename,   /* Database filename (UTF-16) */  /* 数据库文件路径(UTF-16编码) */
  sqlite3 **ppDb          /* OUT: SQLite db handle */  /* 输出: SQLite 数据库句柄 */
);
int sqlite3_open_v2(
  const char *filename,   /* Database filename (UTF-8) */  /* 数据库文件路径(UTF-8编码) */
  sqlite3 **ppDb,         /* OUT: SQLite db handle */  /* 输出: SQLite 数据库句柄 */
  int flags,              /* Flags */
  const char *zVfs        /* Name of VFS module to use */
);
```
说明          
假如这个要被打开的数据库文件不存在，则创建该数据库文件。如果使用`sqlite3_open`和`sqlite3_open_v2`，数据库将采用UTF-8的编码方式，`sqlite3_open16`，数据库将采用UTF-16的编码方式            

参数说明                
`filename`需要被打开的数据库文件的文件名              
`ppDb`一个数据库连接句柄被返回到这个参数，即使发生错误，唯一的异常是如果sqlite不能分配内存来存放sqlite对象，ppDb将会被返回一个NULL值                                 

返回值           
如果成功打开sqlite数据库，返回`SQLITE_OK`, 否则将会返回错误码，大家可能会奇怪为什么下面的返回值，要用-80、80，因为SQLITE_OK其实就是0，所以为了避免使用相同的数字，所以我们从80开始        
无论是否成功打开sqlite数据库，都应该使用sqlite3_close()关闭数据库连接                
```cpp
int Create()
{
	int iErr = 0;

	sqlite3* DB = NULL;
	const char DB_NAME[] = "DB.db";

	int cErr = sqlite3_open(DB_NAME, &DB);
	if (cErr != SQLITE_OK) {
		Close();  /* 无论是否成功打开数据库，都应该使用sqlite3_close()关闭数据库连接 */
		iErr = -80;  /* 创建或打开数据库失败 */
	}
	else
		iErr = 80;  /* 创建或打开数据库 */

	return iErr;
}
```
###关闭数据库
```cpp
void Close()
{
	sqlite3_close(DB);
}
```
###sqlite3_prepare()
把一条SQL语句解析到Statement结构里去，使用该接口访问数据库是当前比较好的一种方法
```cpp
int sqlite3_prepare(
  sqlite3 *db,            /* Database handle */  /* 打开的数据库句柄 */
  const char *zSql,       /* SQL statement, UTF-8 encoded */  /* UTF-8编码的SQL语句,可以参数化 */
  int nByte,              /* Maximum length of zSql in bytes. */  /* SQL语句的字节长度,可以传递-1,即字符串以\0结尾 */
  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */  /* 输出:预编译之后的SQL语句句柄 */
  const char **pzTail     /* OUT: Pointer to unused portion of zSql */  /* 输出: 指向zSql缓冲区中跳过有效SQL字符串的第一个字节 */
);
int sqlite3_prepare_v2(
  sqlite3 *db,            /* Database handle */  /* 打开的数据库句柄 */
  const char *zSql,       /* SQL statement, UTF-8 encoded */  /* UTF-8编码的SQL语句,可以参数化 */
  int nByte,              /* Maximum length of zSql in bytes. */  /* SQL语句的字节长度,可以传递-1,即字符串以宽字符\0结尾 */
  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */  /* 输出:预编译之后的SQL语句句柄 */
  const char **pzTail     /* OUT: Pointer to unused portion of zSql */  /* 输出: 指向zSql缓冲区中跳过有效SQL字符串的第一个字节 */
);
int sqlite3_prepare16(
  sqlite3 *db,            /* Database handle */
  const void *zSql,       /* SQL statement, UTF-16 encoded */
  int nByte,              /* Maximum length of zSql in bytes. */
  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
  const void **pzTail     /* OUT: Pointer to unused portion of zSql */
);
int sqlite3_prepare16_v2(
  sqlite3 *db,            /* Database handle */
  const void *zSql,       /* SQL statement, UTF-16 encoded */
  int nByte,              /* Maximum length of zSql in bytes. */
  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
  const void **pzTail     /* OUT: Pointer to unused portion of zSql */
);
```
这个函数将SQL文本转换成一个准备语句`prepared statement`对象， 同时返回这个对象的指针          

参数        
`db`已经打开的数据库句柄           
`zSql`SQL语句，使用UTF-8编码          
`nByte`如果nByte小于0, 则函数取出`zSql`字符串中从0到第一个`'\0'`终止符的内容           
如果nByte不是负数，那么它就是能从`zSql`中读取的字节数的最大值        
如果nByte非负，zSql在第一次遇见`\000`或`\u0000`的时候终止，如果用户知道被传入的SQL语句是以`'\0'`结尾的，那么有一个更好的做法是,把nByte的值设为该字符串的长度(包含`'\0'`)，这样可以避免SQLite复制该字符串的一份拷贝，以提高程序的效率               
`pzTail`上面提到zSql在遇见终止符或者达到设定的nByte之后结束，假设zSql还有剩余的内容，那么这些剩余的内存被存放到pzTail中，不包括终止符。如果pzTail不为NULL，则pzTail指向zSql中第一个被传入的SQL语句的结尾，该函数只编译SQL的第一个语句，所以pzTail指向的内容则是未被编译的             
`ppStmt` sqlite3_stmt的指针的指针，解析以后的SQL语句就放在这个结构里，如果出错，它就是NULL(例如输入的zSql不是SQL语句),在执行完SQL语句后，必须使用sqlite3_finalize()删除它           

说明          
如果执行成功，则返回SQLITE_OK，否则返回一个错误码，推荐在现在任何的程序中都使用`sqlite3_prepare_v2`这个函数，sqlite3_prepare只是用于前向兼容      

备注         
```cpp
typedef struct sqlite3_stmt sqlite3_stmt;
```
准备语句对象，代表一个简单SQL语句对象的实例，这个对象通常被称为`准备语句`或`编译好的SQL语句`            
它的生命周期是这样的          
1.使用`sqlite3_prepare_v2()`或相关函数创建这个对象         
2.使用`sqlite3_bind_*()`函数给`host parameters`主机参数绑定值         
3.通过调用`sqlite3_step()`一次或多次来执行这个SQL语句       
4.使用`sqlite3_reset()`如果需要重新对预编译的SQL绑定数据并执行,需要先reset一下,然后再调用step，(重置这个语句，然后回到第2步，这个过程做0次或多次)                
5.使用`sqlite3_finalize()`销毁这个对象              

准备SQL语句绑定`host parameters`参数
```cpp
int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
int sqlite3_bind_double(sqlite3_stmt*, int, double);
int sqlite3_bind_int(sqlite3_stmt*, int, int);
int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);
int sqlite3_bind_null(sqlite3_stmt*, int);
int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void(*)(void*));
int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));
int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
```
其中带参数的SQL语句可以这样定义参数
```text
?
?NNN
:VVV
@VVV
$VVV
```
参数编号从1开始,例如:INSERT into db values(?1, ?2)             

在上面的模板中，`NNN`代表一个整数，`VVV`代表一个字母标识符           

对于sqlite3_bind_*()的第一个参数，是一个从sqlite3_prepare_v2()或其他函数返回的sqlite3_stmt对象          
第二个参数是SQL语句中第一个参数的索引值是1，使用`?`的话，会被自动赋予索引值，而使用`?NNN`则可以自己指定参数的索引值，


###SQL操作
```cpp
int sqlite3_exec(sqlite3*, const char* sql, sqlite3_callback, void*, char** errmsg);
```
参数一，sqlite3结构指针，一般指向DB          
参数二，sql语句，以'\0'结尾        
参数三，回调函数，当这条语句执行后，sqlite3会去调用你提供的这个函数               
参数四，void*,是你提供的指针，这个参数最终传到回调函数中去，如果不需要传地址指针给回调函数，可以填NULL        
参数五，错误信息，这是指针的指针，可以直接cout<<errmsg得到错误信息
###回调函数
```cpp
typedef int (*sqlite3_callback) (void*, int, char**, char**);
```
回调函数必须定义成上面的类型       
```cpp
int Load(void* para, int n, char** col, char** name);
```
例如定义成这样         
参数一，sqlite_exec的void*参数      
参数二，此记录列数          
参数三 ，一维数组，查出的结果都在此数组中存放        
参数四，与参数三对应得值所在的列的列名          

###创建一个数据表
创建一个数据表的SQL语句
```cpp
char* sql = "CREATE TABLE 表名(键名 类型, 键名 类型)"
```
```cpp
char* errmsg = "创建数据表失败";
result = sqlite3_exec(DB, "CREATE TABLE mytable(user VARCHAR(45), password VARCHAR(45))", NULL, NULL, &errmsg);
if (result != SQLITE_OK){
	cout<<errmsg<<endl;
}
```

###插入数据
因为我们只是需要插入数据，所以不需要些回调函数 
```cpp
BOOL insert(const char* sql)
{
	result = sqlite3_exec(DB, "INSERT into mytable(user, password) values('aa', 'bb')", NULL, NULL, &errmsg);
	if (result != SQLITE_OK){
		cout<<errmsg<<endl;
	}
}
```

