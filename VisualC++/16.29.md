#SQLite 数据库
SQLite 数据库是一个纯C语言的嵌入式数据库              
讲下为什么样要用这个，因为在做一个MFC程序开发的时候，需要记住用户输入的用户名和密码             
CRegKey操作注册表需要管理员权限，但有时候客户没有管理员权限就没办法操作了         
后来又想用jsoncpp和libjson库来操作json文件，jsoncpp编译后对于std::istream这块不太懂，就没折腾了            
libjson倒是纯C的，问题是在MFC上面编译后，静态引用的时候，问题很多，包括lib文件有5M多，我嫌太大，就直接放弃了              
最后就想起了，SQLite           
[http://www.sqlite.org/](http://www.sqlite.org/)

###编译安装
我下载的Source Code的amalgamation版         
一共4个文件，我直接新建了一个静态库项目把这4个文件，导入后，生成了静态库，然后导入MFC程序

```cpp
#include ".\sqlite\sqlite3.h"
#pragma comment(lib, ".\\sqlite\\sqlite.lib")
```
打开数据库
```cpp
int sqlite3_open(
  const char *filename,   /* Database filename (UTF-8) */
  sqlite3 **ppDb          /* OUT: SQLite db handle */
);
int sqlite3_open16(
  const void *filename,   /* Database filename (UTF-16) */
  sqlite3 **ppDb          /* OUT: SQLite db handle */
);
int sqlite3_open_v2(
  const char *filename,   /* Database filename (UTF-8) */
  sqlite3 **ppDb,         /* OUT: SQLite db handle */
  int flags,              /* Flags */
  const char *zVfs        /* Name of VFS module to use */
);
```
说明          
假如这个要被打开的数据库文件不存在，则创建该数据库文件。如果使用`sqlite3_open`和`sqlite3_open_v2`，数据库将采用UTF-8的编码方式，`sqlite3_open16`，数据库将采用UTF-16的编码方式            

参数说明                
`filename`需要被打开的数据库文件的文件名              
`ppDb`一个数据库连接句柄被返回到这个参数，即使发生错误，唯一的异常是如果sqlite不能分配内存来存放sqlite对象，ppDb将会被返回一个NULL值                                 

返回值           
如果成功打开sqlite数据库，返回`SQLITE_OK`, 否则将会返回错误码，大家可能会奇怪为什么下面的返回值，要用-80、80，因为SQLITE_OK其实就是0，所以为了避免使用相同的数字，所以我们从80开始        
无论是否成功打开sqlite数据库，都应该使用sqlite3_close()关闭数据库连接                
```cpp
int Create()
{
	int iErr = 0;

	sqlite3* DB = NULL;
	const char DB_NAME[] = "DB.db";

	int cErr = sqlite3_open(DB_NAME, &DB);
	if (cErr != SQLITE_OK) {
		Close();  /* 无论是否成功打开数据库，都应该使用sqlite3_close()关闭数据库连接 */
		iErr = -80;  /* 创建或打开数据库失败 */
	}
	else
		iErr = 80;  /* 创建或打开数据库 */

	return iErr;
}
```
关闭数据库
```cpp
void Close()
{
	sqlite3_close(DB);
}
```

###SQL操作
```cpp
int sqlite3_exec(sqlite3*, const char* sql, sqlite3_callback, void*, char** errmsg);
```
参数一，sqlite3结构指针，一般指向DB          
参数二，sql语句，以'\0'结尾        
参数三，回调函数，当这条语句执行后，sqlite3会去调用你提供的这个函数               
参数四，void*,是你提供的指针，这个参数最终传到回调函数中去，如果不需要传地址指针给回调函数，可以填NULL        
参数五，错误信息，这是指针的指针，可以直接cout<<errmsg得到错误信息
###回调函数
```cpp
typedef int (*sqlite3_callback) (void*, int, char**, char**);
```
回调函数必须定义成上面的类型       
```cpp
int Load(void* para, int n, char** col, char** name);
```
例如定义成这样         
参数一，sqlite_exec的void*参数      
参数二，此记录列数          
参数三 ，一维数组，查出的结果都在此数组中存放        
参数四，与参数三对应得值所在的列的列名          

###创建一个数据表
创建一个数据表的SQL语句
```cpp
char* sql = "CREATE TABLE 表名(键名 类型, 键名 类型)"
```
```cpp
char* errmsg = "创建数据表失败";
result = sqlite3_exec(DB, "CREATE TABLE mytable(user VARCHAR(45), password VARCHAR(45))", NULL, NULL, &errmsg);
if (result != SQLITE_OK){
	cout<<errmsg<<endl;
}
```

###插入数据
因为我们只是需要插入数据，所以不需要些回调函数 
```cpp
BOOL insert(const char* sql)
{
	result = sqlite3_exec(DB, "INSERT into mytable(user, password) values('aa', 'bb')", NULL, NULL, &errmsg);
	if (result != SQLITE_OK){
		cout<<errmsg<<endl;
	}
}
```

