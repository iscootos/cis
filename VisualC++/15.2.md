#WNDCLASS结构类型
有了主函数，程序便可以运行了，程序首先找到WinMain入口，然后开始执行，但是注意，此时还没有任何的动作，所以此时的程序运行之后没有任何现象。

也许很多人预想的是，运行一个界面，上面显示一个Hello world。毕竟我们在控制台程序中也是这么过来的。那么我们接下来要做的就是“创建”一个窗口。

首先，创建窗口是由操作系统来创建的，但是窗口创建成什么样呢，这个需要我们来告诉操作系统，但是操作系统不是什么样的窗口都可以创建，它有自己的标准和规范，就是WNDCLASSEX窗口类，我们声明并创建一个WNDCLASSEX窗口类，交给操作系统，操作系统就知道，需要创建一个怎样的窗口了
```cpp
typedef struct tagWNDCLASSEX{
	UINT       cbSize;
	UINT       style;
	WNDPROC    lpfnWndProc;
	int        cbClsExtra;
	int        cbWndExtra;
	HINSTANCE  hInstance;
	HICON      hIcon;
	HCURSOR    hCursor;
	HBRUSH     hbrBackground;
	LPCTSTR    lpszMenuname;
	LPCTSTR    lpszClassName;
	HICON      hIconSm;
} WNDCLASSEX, *PWNDCLASSEX;
```
UINT cbSize UINT是Win32中定义的一个宏, 其实就是一个32位无符号整数, `#define UINT unsigned int`这个变量存储了该结构体的大小赋值时,我们可以使用sizeof(WNDCLASSEX)获取它的大小          
UINT style 这个变量可以定义窗口的风格, 虽然是一个无符号整数, 但是他的取值, 是系统定义好的一组宏变量,可以用or将不同的style链接起来
```text
宏名称                 值            说明
CS_BYTEALIGNCLIENT     0x1000        字节对齐(8的倍数)必须对齐8倍数的客户区左边边界,所以会影响窗口的宽度和水平位置。
CS_BYTEALIGNWINDOW     0x2000        字节对齐(8的倍数)必须对齐8倍数的窗口区左边边界,所以会影响窗口的宽度和水平位置。
CS_CLASSDC             0x0040        所有属于该类的窗口实例共享相同的DC(DC是GDI内部保存的资料结构，就像是内存中的画板，大家都在这个画板上作画，画好了，打印显示在桌面上)
CS_DBLCLKS             0x0008        使窗口可以检测到用户双击鼠标的事件 
CS_DROPSHADOW          0x00020000    使窗口具有阴影效果，必须是顶层窗口，不能应用于子窗口，通过SPI_SETDROPSHADOW关闭
CS_GLOBALCLASS         0x4000        应用程序全局类，定义后，进程内的所有DLL和程序都可以使用它，否则，只有它自己可以使用
CS_HREDRAW             0x0002        窗口的水平尺寸(宽度)被改变的时候，重画整个窗口
CS_NOCLOSE             0x0200        窗口和系统菜单上的关闭命令无效
CS_OWNDC               0x0020        属于此窗口类的窗口实例都有自己的DC(私有DC)，私有DC仅属于该窗口实例，其他程序无法访问和改变私有DC
CS_PARENTDC            0x0080        属于这个类的窗口都使用它的父窗口的句柄，多个窗口共享一个DC,不同的是，这多个窗口(虽然有父子关系，并且共享DC)，并不要求都属于同一个窗口类，效果就是子窗口可以随意在父窗口中作画，就像自己的客户区一样
CS_SAVEBITS            0x0800        系统用位图形式保存一份被窗口遮盖(或灰隐)的屏幕图像,当窗口被删除时，系统使用保存的位图来还原,包括其他被遮盖的窗口
CS_VREDRAW             0x0001        窗口的垂直尺寸(高度)被改变的时候，重画整个窗口
```
WNDPROC lpfnWndProc 这个应该是该结构中最重要的一个成员, 类型WNDPROC的实质是一个指向函数的长整类型的指针. 也就是说我们定义一个窗口, 当鼠标在该窗口上操作, 或键盘按键时, 该窗口收到了这个消息, 此时他的lpfnWndProc指向一个回调函数, 该窗口将参数送到回调函数, 由回调函数执行动作, 之后则可以对动作作出相应          
int cbClsExtra 指明为每个窗口类多分配的额外数据量, 默认为0, 如果是负数, 该窗口类将不会被注册     
int cbWndExtra 指明为每个窗口实例分配的额外数据量, 默认为0, 如果是负数, 该窗口类将不会被注册        
HINSTANCE hInstance 该窗口的句柄     
HICON hIcon 窗口的主图标的句柄         
HCURSOR hCursor 窗口鼠标指针形状的句柄       
HBRUSH hbrBackground 该窗口画刷的句柄(一边以H开头的都是句柄)         
LPCTSTR lpszMenuname 这个变量指向其菜单的名字      
LPCTSTR lpszClassName 该类的名字, 即给该类起一个名字        
HICON hIconSm 这个图标显示的是窗口在任务栏处显示的图标       

到此，可能还有困惑，就是为什么要有个变量存储大小，为什么要有一个变量存储类名。其实很简单，我们以为的都是我们为类声明一个对象，然后不就可以直接使用此对象名引用该窗口类了？其实，这个名字只是存在我们的编译前，当我们定义了一个窗口进程会将窗口的各个成员值放入内存，也就是内存中存着的是各个成员的值，那么此时我们生命的对象名还有吗？当然不在了，所以我们要在内存中存一个名称，当然了这个名称不一定要是WNDCLASSEX我们可以任意起名。
```cpp
typedef struct tagWNDCLASS{
	UINT       style;
	WNDPROC    lpfnWndProc;
	int        cbClsExtra;
	int        cbWndExtra;
	HINSTANCE  hInstance;
	HICON      hIcon;
	HCURSOR    hCursor;
	HBRUSH     hbrBackground;
	LPCTSTR    lpszMenuName;
	LPCTSTR    lpszClassName;
} WNDCLASS, *PWNDCLASS;
```
```cpp
LRESULT CALLBACK WindowProc(
		HWND     hwnd,
		UINT     uMsg,
		WPARAM   wParam,
		LPARAM   lParam
);
```
LRESULT l就是long长整形, result表示结果，说明这个函数的返回值是某个结果         
HWND hwnd 指向窗口的句柄           
UINT uMsg 指定消息类型        
WPARAM wParam 消息参数, 附加消息，这个参数的内容取决于uMsg参数的值       
LPARAM lParam 消息参数, 附加消息，这个参数的内容取决于uMsg参数的值      
每个窗口都有一个称为窗口过程的回调函数,当窗口收到消息时系统就会调用此窗口过程来处理消息(所以叫回调函数)
```cpp
LRESULT WINAPI DefWindowProc(
		HWND     hWnd,
		UINT     Msg,
		WPARAM   wParam,
		LPARAM   lParam
);
```
```cpp
ATOM WINAPI RegisterClassEx(
		WNDCLASSEX  *lpwcx
);
```
```cpp
HWND WINAPI CreateWindow(
		LPCTSTR     lpClassName,
		LPCTSTR     lpWindowName,
		DWORD       dwStyle,
		int         x,
		int         y,
		int         nWidth,
		int         nHeight,
		HWND        hWndParent,
		HMENU       hMenu,
		HINSTANCE   hInstance,
		LPVOID      lpParam
);
```
```cpp
BOOL WINAPI ShowWindow(
		HWND        hWnd,
		int         nCmdShow
);
```
```cpp
BOOL UpdateWindow(
		HWND        hWnd
);
```
```cpp
BOOL WINAPI GetMessage(
		LPMSG       lpMsg,
		HWND        hWnd,
		UINT        wMsgFilterMin,
		UINT        wMsgFilterMax
);
```
现在我们来写第一个图形界面的Windows程序
```cpp
#include <Windows.h>
#pragma comment(lib, "User32.lib")

/* 全局变量 */
HINSTANCE hinst;

/* 函数声明 */
int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);



int WINAPI WinMain(
	HINSTANCE hInstance,
	HINSTANCE hPrevInstance,
	LPSTR lpCmdLine,
	int nCmdShow
	)
{
	WNDCLASSEX wcx;
	HWND hwnd;
	MSG msg;
	BOOL fGotMessage;
	hinst = hInstance;
	wcx.cbSize = sizeof(wcx);
	wcx.style = CS_HREDRAW | CS_VREDRAW;
	wcx.lpfnWndProc = MainWndProc;
	wcx.cbClsExtra = 0;
	wcx.cbWndExtra = 0;
	wcx.hInstance = hInstance;
	wcx.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wcx.hCursor = LoadCursor(NULL, IDC_ARROW);
	wcx.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
	wcx.lpszMenuName = NULL;
	wcx.lpszClassName = L"MainWClass";
	wcx.hIconSm = (HICON) LoadImage(hInstance,
		MAKEINTRESOURCE(5),
		IMAGE_ICON,
		GetSystemMetrics(SM_CXSMICON),
		GetSystemMetrics(SM_CYSMICON),
		LR_DEFAULTCOLOR
		);

	if (!RegisterClassEx(&wcx))
	{
		return 1;
	}

	hwnd = CreateWindow(
		L"MainWClass",
		L"标题",
		WS_EX_OVERLAPPEDWINDOW,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		NULL,
		NULL,
		hInstance,
		(LPVOID)NULL
		);

	if (!hwnd)
	{
		return 1;
	}

	ShowWindow(hwnd, nCmdShow);
	UpdateWindow(hwnd);

	while ((fGotMessage = GetMessage(&msg, (HWND) NULL, 0, 0)) != 0 && fGotMessage != -1)
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	return msg.wParam;
}

LRESULT CALLBACK MainWndProc(HWND hwnd,
	UINT uMsg,
	WPARAM wParam,
	LPARAM lParam
	)
{
	switch (uMsg)
	{
	case WM_DESTROY:
		ExitThread(0);
		return 0;
	default:
		return DefWindowProc(hwnd, uMsg, wParam, lParam);
	}
}
```
