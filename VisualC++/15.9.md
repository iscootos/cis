#线程Thread
###CreateThread
创建线程
```cpp
HANDLE WINAPI CreateThread(
  _In_opt_   LPSECURITY_ATTRIBUTES lpThreadAttributes,
  _In_       SIZE_T dwStackSize,
  _In_       LPTHREAD_START_ROUTINE lpStartAddress,
  _In_opt_   LPVOID lpParameter,
  _In_       DWORD dwCreationFlags,
  _Out_opt_  LPDWORD lpThreadId
);
```
lpThreadAttributes 值为NULL，表示默认安全属性，对象句柄不能继承，或者指向一个SECURITY_ATTRIBUTES结构的指针          
dwStackSize 指定线程可以为其线程栈使用多少地址空间。每个线程都拥有自己的栈，值0，系统自动分配适合线程的栈空间，如果值不为0，单位字节，那么系统使用指定大小的栈空间，可能出现线程溢出                
lpStartAddress 线程函数的入口，函数格式按照如下的ThreadProc           
```cpp
DWORD WINAPI ThreadProc(
  _In_  LPVOID lpParameter
);
```
lpParameter 线程函数的参数，值NULL，表示没有参数，值this，表示把对象本身作为参数传递，推荐使用               
dwCreationFlags 控制线程创建的标志            
```text
值                                                     说明
0                                                      线程创建后立即运行
CREATE_SUSPENDED                      0x00000004       系统创建并初始化线程，但是会暂停线程的运行，这样它就无法调度，使用ResumeThread函数恢复    
STACK_SIZE_PARAM_IS_A_RESERVATION     0x00010000       如果没有设置该值，dwStackSize栈空间为系统默认分配的大小，默认为1MB，有的系统为4MB         
```
lpThreadId 用来存储系统分配给新线程的ID,它必须是DWORD类型，值NULL，表示我们不需要线程ID              

返回值：成功返回新的线程句柄，失败返回NULL                 

####创建一个线程，并输出"hello world"
主线程如果不暂停Sleep，那么新线程的字符串还没有打印，就已经结束了
```cpp
DWORD WINAPI Xfun(LPVOID lpParameter)
{
	char* x = (char*)lpParameter;
	printf("%s\n", x);
	return (DWORD)0;
}

int _tmain(int argc, _TCHAR* argv[])
{
	char *x = "hello world";
	LPVOID A = (LPVOID)x;
	HANDLE Z = CreateThread(NULL, 0, Xfun, A, 0, NULL);
	CloseHandle(Z);
	
	if (Z == NULL)
		return 0;
	else
		Sleep(10);

	return 0;
}
```
###AfxBeginThread
MFC程序 创建线程
```cpp
CWinThread* AfxBeginThread(
   AFX_THREADPROC pfnThreadProc,
   LPVOID pParam,
   int nPriority = THREAD_PRIORITY_NORMAL,
   UINT nStackSize = 0,
   DWORD dwCreateFlags = 0,
   LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL 
);
CWinThread* AfxBeginThread(
   CRuntimeClass* pThreadClass,
   int nPriority = THREAD_PRIORITY_NORMAL,
   UINT nStackSize = 0,
   DWORD dwCreateFlags = 0,
   LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL 
);
```
pfnThreadProc 线程函数，函数格式如下
```cpp
UINT __cdecl MyControllingFunction( LPVOID pParam );
```
pParam 线程函数的参数                    

返回值: 成功返回CWinThread 对象指针，失败返回NULL           
```cpp
static UINT __cdecl Xfun(LPVOID pParam);

UINT __cdecl CMFCApplication2App::Xfun(LPVOID pParam)
{
	AfxMessageBox(_T("hello world"));
	return DWORD(0);
}

CMFCApplication2App::CMFCApplication2App()
{
	// TODO:  在此处添加构造代码，
	// 将所有重要的初始化放置在 InitInstance 中

	CWinThread* x = AfxBeginThread(Xfun, NULL);
	
}
```
###关键段 critical section
CRITICAL_SECTION数据结构            
```cpp
VOID InitializeCriticalSection(PCRITICAL_SECTION pcs);
```
pcs 指向CRITICAL_SECTION数据结构的指针               
```cpp
VOID EnterCriticalSection(PCRITICAL_SECTION pcs);
```
EnterCriticalSection函数等待CRITICAL_SECTION数据结构没有被其他线程使用，再执行，也就是说如果其他线程在使用的时候，它就一直等待            
```cpp
VOID DeleteCriticalSection(PCRITICAL_SECTION pcs);
```
```cpp
BOOL TryEnterCriticalSection(PCRITICAL_SECTION pcs);
```
TryEnterCriticalSection检测CRITICAL_SECTION数据结构是否被其他线程使用，如果是返回FALSE,没有使用返回TRUE                 
```cpp
VOID LeaveCriticalSection(PCRITICAL_SECTION pcs);
```
LeaveCriticalSection函数把CRITICAL_SECTION数据结构的计数器减1，该计数器表示调用线程获准访问共享资源的次数                        
```cpp
CRITICAL_SECTION pcs;

InitializeCriticalSection(&pcs);  /* 载入CRITICAL_SECTION结构 */
EnterCriticalSection(&pcs);  /* 检查是否被使用 */
//code
LeaveCriticalSection(&pcs);  /* 离开，使用次数减1 */
```
实例讲解，多线程共享一个资源，如何实现排队处理，pcs我们理解为一个马桶，InitializeCriticalSection我们理解为卫生间，首先我们把马桶放入卫生间，EnterCriticalSection是检查卫生间是否有人在使用，如果有人在使用卫生间，那么我们就等着，LeaveCriticalSection表示使用卫生间的人已经离开，那么其他人可以去卫生间了,code呢，就是卫生间中的其他物品，每一个上卫生间的人都可以使用               
###旋转锁
设置关键段的旋转次数
```cpp
BOOL InitializeCriticalSectionAndSpinCount(PCRITICAL_SECTION pcs, DWORD dwSpinCount);
```
上面我们已经知道，如果卫生间有人，我们就会一直等待，但是系统会把线程切换到等待状态，这个切换开销非常大，所以我们使用旋转锁，也就是在检查几次卫生间是否有人后，再切换为等待状态，这就大大提高的效率，            
pcs 依然是卫生间，dwSpinCount是检查卫生间有人的次数,如果CPU是单核的话，函数会忽略dwSpinCount参数，用来保护进程堆的关键段所使用的旋转次数大约是4000，这可以作为我们的一个参考值          
           
修改关键段的旋转次数          
```cpp
DWORD SetCriticalSectionSpinCount(PCRITICAL_SECTION pcs, DWORD dwSpinCount);
```
###线程等待状态
等待函数使一个线程自愿进入等待状态，直到指定的内核对象被触发为止
```cpp
DWORD WINAPI WaitForSingleObject(
  _In_  HANDLE hHandle,
  _In_  DWORD dwMilliseconds
);
```
hHandle 对象句柄，直到要等待的内核对象           
dwMilliseconds 时间间隔，单位毫秒，值为非零，函数等到对象被触发或时间到了，值为0，立即返回，值为INFINITE，等到对象被触发，才会返回               

返回值：
```text
返回值               说明
WAIT_ABANDONED       指定的对象是mutex对象
WAIT_OBJECT_0        线程等待的对象被触发
WAIT_TIMEOUT         等待超时
WAIT_FAILED          等待失败，无效的对象句柄
```
###WaitForMultipleObjects
线程检查多个内核对象的触发状态
```cpp
DWORD WINAPI WaitForMultipleObjects(
  _In_  DWORD nCount,
  _In_  const HANDLE *lpHandles,
  _In_  BOOL bWaitAll,
  _In_  DWORD dwMilliseconds
);
```
nCount 检查内核对象的数量，值必须在1-MAXIMUM_WAIT_OBJECTS(winnt.h头文件中定义为64)之间，不能为0              
lpHandles 一个指针，指向一个内核对象的数组            
bWaitAll 值TRUE，所有内核对象触发之前，函数将不会允许调用线程继续执行，值FALSE，内核对象的一个被触发，函数就允许线程继续执行             
dwMilliseconds 时间间隔，单位毫秒，值为非零，函数等到对象被触发或时间到了，值为0，立即返回，值为INFINITE，等到对象被触发，才会返回             
    




