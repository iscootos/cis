#TCP粘包
再讲TCP粘包之前，先来讲下TCP的原理，TCP是以`流`的方式来传输数据              

1.可靠性，就是甲给乙传300个字节，TCP协议能保证这300个字节一个不少的传给乙                   
2.`流`特性，你可以想象TCP协议下的网络传输就是一条河流，这条`河流`的`河水`不是平坦的，而是起伏不平，具体就是说你再客户端开辟一个100字节的接收缓冲区，每次你实际接收的字节数有可能是0到100            
3.顺序性，TCP协议保证后面服务器端发给客户端的数据不会跑到前面发的数据去，所有接收数据的顺序都按照发送顺序来                    

发送端可以1K、1K的发送数据，而接收端的应用程序可以两2K、2K的提走数据，当然也有可能一次提走3K、6K数据，或者一次只提走几个字节的数据，也就是说，应用程序所看到的数据是一个整体，或说是一个流(stream)，一条消息有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议，这也是容易出现粘包问题的原因。TCP协议层会把构成整条消息的数据包排序完成后才呈现在内核缓冲区，所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据优化算法把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据              

假设主机A send了两条消息M1和M2各10K给主机B，由于主机B一次接收的字节数是不确定的，接收方收到数据的情况可能是             
一次性收到20K数据              
分两次收到，第一次5K，第二次15K            
分两次收到，第一次15K，第二次5K            
分两次收到，第一次10K，第二次10K            
分三次收到，第一次6K，第二次8K，第三次6K   
其他任何可能         


为了解决粘包问题，所以我们需要知道包的分界,那么我们可以在包头添加一个长度结构
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct _cis_packet {
	unsigned __int16 length;
} cis_packet;

int main()
{
	char *data = "hello world";
	cis_packet buf;  /* 长度包 */
	buf.length = strlen(data) + 1;  /* 数据包长度 */

	char x[1024];
	memset(x, 0, 1024);  /* 把字符串都重置为0 */
	memcpy(x, &buf, sizeof(buf));  /* 封包 */
	memcpy(x + sizeof(buf), data, buf.length);  /* 封包 */

	cis_packet* z = (cis_packet*)x;  /* 解包 */
	printf("%d\n", z->length);
	printf("%s\n", x + sizeof(buf));

	return 0;
}
```
那么如上，就是封包和解包的方法       
